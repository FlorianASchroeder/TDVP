classdef TDVPData
	% The 'TDVPData' class is used to load, process and analyze data
	% generated by VMPS/TDVP code
    %
	
	% Defines all properties of objects from class 'TDVPData'.
    % They are accessed by objName.property
    properties
		tCalc;		% t of the simulation
		dt;			% timesteps
		t;			% t of observables
		tS;			% t of star extraction
		omega;		% frequency axis for star picture
		para;
		tresults;
		version;
		nChains;
		% for SBM:
		alpha;		% if Spin-Boson
		s;			% if Spin-Boson
		spin;		% Spin Observable
		% for DPMES
		CTShift;	% string
		% for all
		lastIdx;    % last Observable Idx
		occC;		% chain occupation
		occCd;		% chain occupation, diabatic projection
		occCa;		% chain occupation, adiabatic projection
		occCc;		% chain occupation, |TT><LE+| coherence projection
		occS;		% star occupation
		xC;			% chain displacement
		xCd;		% chain displacement, diabatic projection
		xCa;		% chain displacement, adiabatic projection
		xCc;		% chain displacement, |TT><LE+| coherence projection
		xC2;		% chain <x^2>
		xC2d;		% chain <x^2>, diabatic projection
		xC2a;		% chain <x^2>, adiabatic projection
		xS;			% star displacement
		jC;			% chain current
		rho;		% rduced density matrix
		rhoOscRes;	% residual of populations after exponential fit
		stateProj;	% state projection amplitude
		sysState;	% state of system
        mps;        % MPS and Vmat of sites 1&2
        Vmat;
		LegLabel;	%
		Comment;	% 
		folder;		% for easy identification
	end
	
	methods
			
		
		function obj = TDVPData(fname,varargin)
			% obj = TDVPData(para,tresults)
			%
			% Load TDVP dataset into a TDVPData object
			if nargin > 1
				% TDVPData(para,tresults)
				% fname = para, varargin{1} = tresults
				if isstruct(fname) && isstruct(varargin{1})
					temp.para = fname;
					temp.tresults = varargin{1};
				else
					fprintf('please program me\n');
				end
			elseif nargin == 0
				return;		% empty initialization
			elseif nargin == 1 && ischar(fname)
				try
					temp = load(fname,'para','tresults');
					% Deserialize if needed
					Vars = fields(temp);
					for ii = 1:size(Vars)
						x = temp.(Vars{ii});
						if isa(x,'uint8')
							temp.(Vars{ii}) = hlp_deserialize(x);
	% 						eval(sprintf('%s = hlp_deserialize(%s);',Vars(ii).name,Vars(ii).name));
						end
					end
				catch err
					fprintf('load failed for: %s\n',fname);
					return;
				end
			elseif iscell(fname)
				% TDVPData({file1,file2,file3,...}
				% to be loaded into TDVPData array!
				L = length(fname);
				obj(L,1) = TDVPData();
				for ii = 1:L
					obj(ii) = TDVPData(fname{ii});
				end
				return;
			end
			
			% assign parameters
			if isfield(temp, 'para') && isfield(temp,'tresults')
				obj.para = temp.para;
				obj.tresults = temp.tresults;
			end
			if isfield(obj.para.tdvp,'version')
				obj.version = str2double(obj.para.tdvp.version(2:end));
			else
				obj.version = 0;
			end
			
			if isfield(obj.tresults,'spin')
				obj.spin = zeros(obj.lastIdx,3,'single');				% t x 3
				obj.spin(:,1) = obj.tresults.spin.sx(1:obj.lastIdx);
				obj.spin(:,2) = obj.tresults.spin.sy(1:obj.lastIdx);
				obj.spin(:,3) = obj.tresults.spin.sz(1:obj.lastIdx);
			end
			
			if obj.version >= 50 && isfield(obj.tresults,'n')
				obj.occC = obj.tresults.n;
			elseif isfield(obj.tresults,'nx')
				obj.occC = real(obj.tresults.nx);
			end
			if obj.version >= 72 && isfield(obj.tresults,'na')
				obj.occCa = obj.tresults.na;
				if isempty(obj.occC)
					obj.occC = squeeze(sum(real(obj.occCa),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'nd')
				obj.occCd = obj.tresults.nd;
				if isempty(obj.occC)
					obj.occC = squeeze(sum(real(obj.occCd),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'nc')
				obj.occCc = obj.tresults.nc;
			end
			
			if obj.version >= 66 && isfield(obj.tresults,'x')
				if ndims(obj.tresults.x) == 3
					obj.xC = obj.tresults.x;
				elseif ~isempty(strfind(obj.para.tdvp.Observables,'.x.'))		% support for version <=72
					obj.xCd = obj.tresults.x;
					if isempty(obj.xC)
						obj.xC = squeeze(sum(real(obj.xCd),3));
					end
				elseif ~isempty(strfind(obj.para.tdvp.Observables,'.x2.'))		% support for version <=72
					obj.xCa = obj.tresults.x;
					if isempty(obj.xC)
						obj.xC = squeeze(sum(real(obj.xCd),3));
					end
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'xa')
				obj.xCa = obj.tresults.xa;
				if isempty(obj.xC)
					obj.xC = squeeze(sum(real(obj.xCa),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'xd')
				obj.xCd = obj.tresults.xd;
				if isempty(obj.xC)
					obj.xC = squeeze(sum(real(obj.xCd),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'xc')
				obj.xCc = obj.tresults.xc;
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2')
				obj.xC2 = obj.tresults.x2;
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2a')
				obj.xC2a = obj.tresults.x2a;
				if isempty(obj.xC2)
					obj.xC2 = squeeze(sum(real(obj.xC2a),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2d')
				obj.xC2d = obj.tresults.x2d;
				if isempty(obj.xC2)
					obj.xC2 = squeeze(sum(real(obj.xC2d),3));
				end
			end
			
			if obj.version >= 42 && isfield(obj.tresults,'t')
				obj.t = obj.tresults.t;
			else
				obj.t = obj.para.tdvp.t;
			end
			obj.tCalc = obj.para.tdvp.t;
			obj.dt    = obj.para.tdvp.deltaT;
			
			if isfield(obj.para,'nChains')
				obj.nChains = obj.para.nChains;
			else
				obj.nChains = 1;
			end
			
			if isfield(obj.tresults,'rho')
				obj.rho = obj.tresults.rho;
			else
				obj.rho = [];
			end
			obj.rhoOscRes = [];
			
			if isfield(obj.tresults,'system') && isfield(obj.tresults.system,'state')
				obj.sysState = obj.tresults.system.state;
			else
				obj.sysState = [];
			end
			
			if isfield(obj.tresults,'lastIdx')
				obj.lastIdx = obj.tresults.lastIdx;
			else
				obj.lastIdx = size(obj.tresults.nx,1);
			end
			
			% save star observables
			if isfield(obj.tresults,'star')
				if isfield(obj.tresults.star,'n')
					obj.occS  = obj.tresults.star.n;
					if obj.version <= 42 && size(obj.occS,1) == length(obj.tresults.star.omega)
						obj.occS = obj.occS.';
					end
				else
					obj.occS = 0;
				end
				if isfield(obj.tresults.star,'x')
					obj.xS    = obj.tresults.star.x;
				else
					obj.xS = 0;
				end
				obj.tS    = obj.tresults.star.t;
				if size(obj.tresults.star.omega,1) ~= 1
					obj.omega = obj.tresults.star.omega;		% w x nChains
				else
					obj.omega = obj.tresults.star.omega.';		% w x 1
				end
			end
			
			% extract simulation parameters SBM
			if ~isempty(strfind(obj.para.model,'SpinBoson'))
				if isa(obj.para.chain,'struct')
					if isfield(obj.para,'alpha')
						obj.alpha = obj.para.alpha;
					end
					if isfield(obj.para,'s')
						obj.s = obj.para.s;
					end

				elseif isa(obj.para.chain,'cell')
					obj.alpha = cellfun(@(x) x.alpha, obj.para.chain);
					obj.s     = cellfun(@(x) x.s    , obj.para.chain);
				end
			end
			
			if isfield(obj.tresults,'stateProjection')
				obj.stateProj = obj.tresults.stateProjection;
			end
			
			if isfield(obj.tresults,'mps')
                obj.mps = obj.tresults.mps;
                obj.tresults.mps = [];
                obj.Vmat = obj.tresults.Vmat;
                obj.tresults.Vmat = [];
			end
			
			if ~isempty(strfind(obj.para.model,'DPMES'))
				% any particular vars for DPMES?
				temp = regexp(obj.para.folder,'CT([-.0-9]*)','tokens');
				if ~isempty(temp)
					obj.CTShift = temp{1}{1};
				else
					temp = regexp(obj.para.folder,'Delta([-.0-9]*)State','tokens');
					if ~isempty(temp)
						obj.CTShift = temp{1}{1};
					else
						obj.CTShift = 0;	% give up
					end
				end
			end
			obj.LegLabel = '';
			obj.folder = obj.para.folder;
		end
		
		function obj = setLegLabel(obj,entry)
			if ~isa(entry,'string')
				obj.LegLabel = num2str(entry);
			else
				obj.LegLabel = varName;
			end
		end
		
		function obj = setComment(obj, str)
			obj.Comment = str;
		end
		
		function out = gettRhoiiSystem(obj)
			% DEPRECATED
			% returns the diagonal of the system reduced density matrix
			out = 0;
			if isfield(obj.tresults,'PPCWavefunction')
				out = obj.tresults.PPCWavefunction;
			elseif isfield(obj.tresults,'rho')
				out = cell2mat(arrayfun(@(i) diag(squeeze(obj.tresults.rho(i,:,:))),1:size(obj.tresults.rho,1),'UniformOutput',false)).';
			end
		end
		
		function out = getData(obj,type,varargin)
			% returns certain data or observables
			full = 0;		% truncate to simulated time - tresults.lastIdx
			idxOffset = 0;
			out = 0;
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-full'
						full = 1;
				end
			end
			
			switch lower(type)
				case 'calctime'
					out = obj.para.tdvp.calcTime;
					idxOffset = 1;
				case 'calctime-d'
					out = diff(obj.para.tdvp.calcTime);
					idxOffset = 2;
				case 'rhoii'
					if isfield(obj.tresults,'PPCWavefunction')
						rhoii = obj.tresults.PPCWavefunction;
					elseif isfield(obj.tresults,'rho')
						rhoii = cell2mat(arrayfun(@(i) diag(squeeze(obj.tresults.rho(i,:,:))),1:obj.lastIdx,'UniformOutput',false)).';
					else
						warning('TDVPData:getData:rhoii','rho does not exist');
						rhoii = 0;
					end
					out = rhoii;
					full = 1;
				case 'rhoii-osc-res'
					% oscillating residuals
					plotFit = 1;						% 1: plot the fitted functions into separate figure to evaluate fitness.
					rhoii = abs(obj.getData('rhoii'));		% t x dk(1)
					out = zeros(size(rhoii));
					% fit and remove exponential components to obtain the residuals
					if plotFit
						f = gcf;
						figure; hold all; ax = gca;
						plot(obj.t(1:obj.lastIdx),rhoii);
						ax.ColorOrderIndex = 1;					% reset to have fit in same color as original data
					end
					for m = 1:size(rhoii,2)
						fun{1} = @(x,xdata) x(1)+x(2).*exp(x(3).*xdata);					% exponential model with shift
						fun{2} = @(x,xdata) x(1)+x(2).*exp(x(3).*xdata)+x(4).*exp(x(5).*xdata);					% exponential model with shift
						a0{1} = double([rhoii(end,m),rhoii(1,m)-rhoii(end,m),-0.01]);								% initial guesses
						if rhoii(1,m) == 0
							a0{1}(3) = mean(diff(rhoii(100:200,m)))/obj.t(2);			% rise if starting from 0
						end
						a0{2} = double([rhoii(end,m),rhoii(1,m)-rhoii(end,m),-0.01,rhoii(1,m)-rhoii(end,m),+0.01]);								% initial guesses
						for k = 1:length(fun)
							[x{k},r(k),res{k}] = lsqcurvefit(fun{k},a0{k},double(obj.t(1:obj.lastIdx).'), double(rhoii(:,m)));
						end
						[~,ind] = min(r);		% pick function with minimal residual norm;
						if plotFit, plot(obj.t(1:obj.lastIdx),fun{ind}(x{ind},obj.t(1:obj.lastIdx))); end
						out(:,m) = res{ind};		% save the residual
					end
					if plotFit,	figure(f); end
					full = 1;
				case 'rhoii-osc-res-med'
					% oscillating residuals
					rhoii = abs(obj.getData('rhoii'));		% t x dk(1)
					% fit by smoothing and remove exponential components to obtain the residuals
					out = TDVPData.movAvgRes(rhoii,170/obj.t(2));		% 170 or 350
					full = 1;
				case 'rhoii-osc-res-mean'
					% oscillating residuals by removing DC via mean
					out = TDVPData.meanRes(abs(obj.getData('rhoii')));
					full = 1;
				case 'rhoij'
					% out{1}: t x #off-diagonal elements
					% out{2}: [from,to] x #off-diagonal elements
					%			carries information to identify objects in out{1}
					if ~isfield(obj.tresults,'rho') || isempty(obj.tresults.rho)
						error('TDVPData:getData:rhoij','rho does not exist')
					end
					out = {};
					r = obj.tresults.rho(1:obj.lastIdx,:,:);
					d = size(r);
					out{1} = zeros(d(1),d(2)*(d(2)-1)/2-1);				% calculates number of off-diagonals
					out{2} = zeros(2,size(out,2));
					iC = 1;
					for jj = 1:d(2)
						for ii = jj:d(2)
							if ii ~= jj
								out{1}(:,iC) = r(:,ii,jj);				% get offdiag
								out{2}(:,iC) = [jj,ii];
								iC = iC+1;
							end
						end
					end
					full = 1;
				case 'vne'
					% von Neumann Entropy = -tr(r ln r)
					rdm = obj.tresults.rho;						% t x i x j
					out = zeros(size(rdm,1),1);					% t x 1
					rdm = permute(rdm,[2,3,1]);					% i x j x t
					for ii = 1:length(out)
						out(ii) = real(-sum(sum(rdm(:,:,ii).*log(rdm(:,:,ii).'))));
					end
                case 'sys-env-x'
					out = obj.getSysEnvObs('x');			% returns t x NC cell array; using mps(:,2), Vmat(:,2)
					full = 1;
                case 'sys-env-n'
					out = obj.getSysEnvObs('n');			% returns t x NC cell array; using mps(:,2), Vmat(:,2)
                    full = 1;
				case 'spin'
					
			end
			
			if ~full
				out = out(1:obj.tresults.lastIdx-idxOffset);	% truncate if wanted
			end
		end
		
		function [h,pl,obj] = plot(obj,type,varargin)
			%% Simple 1D plots for following Observables:
			% type:
			%	'sz'
			%	'spin'
			%	'calctime'
			%	'calctime-d'
			%	'calctime-d-sec'
			%	'rhoii'
			%	'rho-current'
			%	'rho-dpmes'
			%	'rhoij-real'
			%	'rhoij-imag'
			%	'rhoij-abs'
			%	'hshi'
			%	'stateproj'
			%	'chain-x-t-avg'
			%	'linabs'
			%	'rhoii-ft'
			%	'rhoii-osc-res'
			%	'rhoii-osc-res-med'

			% initialise modifiers
			% plot(...,ax_handle)	Plots into the axes/figure given by handle
			if length(obj) > 1
				% deal with object array
				pl = gobjects(length(obj),1);
				for ii = 1:length(obj)
					[hTemp,plTemp,obj(ii)] = obj(ii).plot(type,varargin{:});
					plTemp = reshape(plTemp,1,[]);
					if size(pl,2) ~= size(plTemp,2)
						pl(end,size(plTemp,2)) = gobjects(1,1);
					end
					pl(ii,:) = plTemp;
					h(ii) = hTemp;
				end
				return;
			end
			h.xlbl = 't';
			h.ylbl = [];
			h.leglbl = {};
			h.xdata = [];
			h.ydata = [];
			h.pl = [];					% plot handle
			pl = [];					% old plot handle;
			
			ts = 1;						% scale time axis
			eScale = 0;					% energy units used for DFT: 0 = none, 1 = eV, 2 = cm (wavenumber)
			unicolor = 0;
			resetColorOrder = 0;		% start from index 1
			plotOpt = {};				% additional plotOptions from varargin
			DFTplot = 0;				% plotting DFT data
			DFTshift = 0;				% shift the fft results
			h.normalise = 0;				% normalise to maximum peak (for FFT especially)
			h.distribute = 0;			% distribute plot lines along y; only use if h.normalise = 1, otherwise gets messy
			
			h.f  = [];
			h.ax = [];
			
			for m = 1:nargin-2
				if isobject(varargin{m})
					if isa(varargin{m},'matlab.ui.Figure')
						h.f  = varargin{m};
					elseif isa(varargin{m},'matlab.graphics.axis.Axes')
						h.ax = varargin{m};
					end
					continue;
				end
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV and eV scale in DFT plots
						ts = 0.658;
						eScale = 1;
						h.xlbl = '$t/fs$';
					case '-cmev'
						% cm scale in DFT plots
						ts = 0.658;
						eScale = 2;
						h.xlbl = '$E/cm^{-1}$';
					case '-nmev'
						% nm scale in DFT plots
						ts = 0.658;
						eScale = 3;
						h.xlbl = '$\lambda/nm$';
					case '-fftshift'
						DFTshift = 1;
					case '-unicol'
						% same colors on all lines
						unicolor = 1;
					case '-resetcolororder'
						resetColorOrder = 1;
					case '-norm'
						h.normalise = 1;
					case '-dist'
						h.distribute = 1;
					otherwise
						% pass through as direct plot options!
						plotOpt = [plotOpt, varargin(m)];
				end
			end

			% Create figure handles and panels
			if isempty(h.f)
				if isempty(h.ax)
					h.f = figure();
				else
					axes(h.ax);					% select axes
					h.f = gcf;					% get their figure
				end
			end
			if isempty(h.ax)
				h.ax = gca;
			end
			h.f.Renderer = 'painters';				% provides much better 2D results generally!
			hold all;
			
			if resetColorOrder
				h.ax.ColorOrderIndex = 1;
			end
			
			if unicolor
				idx = h.ax.ColorOrderIndex;
			end
			
			switch lower(type)
				case 'sz'
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = obj.tresults.spin.sz(1:obj.lastIdx);
					h.leglbl = {obj.LegLabel};
					h.ylbl = '$\left<\sigma_z\right>$';
				case 'spin'
					if isempty(obj.spin)
						disp('please calculate spin first');
						return;
					else
						h.xdata = obj.t(1:obj.lastIdx)*ts;
						h.ydata = [obj.spin,sqrt(obj.spin(:,1).^2+obj.spin(:,2).^2)];
						h.leglbl = {'$\left<\sigma_x\right>$','$\left<\sigma_y\right>$','$\left<\sigma_z\right>$','$\sqrt{\left<\sigma_x\right>^2+\left<\sigma_y\right>^2}$'};
					end
					h.ylbl = '$\left<\sigma\right>$';
				case 'calctime'
					h.xdata  = obj.t(2:obj.lastIdx)*ts;
					h.ydata  = obj.para.tdvp.calcTime(1:obj.lastIdx-1);
					h.leglbl = {obj.LegLabel};
					h.ylbl   = 'CPU time/h';
				case 'calctime-d'
					% 1st derivative, in hours
					h.xdata  = obj.t(2:obj.lastIdx-1)*ts;
					h.ydata  = diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1));
					h.leglbl = {obj.LegLabel};
					h.ylbl = 'CPU time/sweep/h';
				case 'calctime-d-sec'
					% 1st derivative, in seconds
					h.xdata = obj.t(2:obj.lastIdx-1)*ts;
					h.ydata = 3600*diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1));
					h.leglbl = {obj.LegLabel};
					h.ylbl = 'CPU time/sweep/s';
				case 'rhoii'
					box on;
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = abs(obj.getData('rhoii'));
					h.leglbl = arrayfun(@(i) sprintf('$%d$',i),(1:size(h.ydata,2))','UniformOutput',false);
					h.ylbl = '$\rho_{ii}(t)$';
				case 'rhoij-real'
					if ~isfield(obj.tresults,'rho'), return, end;
					box on;
					r = obj.getData('rhoij');							% {rhoij, info}
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = real(r{1});
					h.leglbl = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					h.ylbl = 'Re($\rho_{ij})$';
				case 'rhoij-imag'
					if ~isfield(obj.tresults,'rho'), return, end;
					box on;
					r = obj.getData('rhoij');							% {rhoij, info}
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = imag(r{1});
					h.leglbl = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					h.ylbl = 'Im($\rho_{ij})$';
				case 'rhoij-abs'
					if ~isfield(obj.tresults,'rho'), return, end;
					box on;
					r = obj.getData('rhoij');							% {rhoij, info}
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = abs(r{1});
					h.leglbl = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					h.ylbl = '$|\rho_{ij}|$';
				case 'rho-current'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.tresults.rho(1:obj.lastIdx,:,:);
					d = size(r);
					rhoDiag = zeros(d([1,2]));
					LegLabD = cell(1,d(2));
					rhoCur = zeros(d(1),d(2)*(d(2)-1)/2-1);				% calculates number of off-diagonals
					LegLabCur = cell(1,size(rhoCur,2));
					iC = 1;
					for jj = 1:d(2)
						for ii = 1:jj
							if ii == jj
								rhoDiag(:,ii) = real(r(:,ii,jj));		% get population
								LegLabD{ii} = sprintf('$%d$',ii);
							else
								rhoCur(:,iC)  = real(r(:,ii,jj));		% get Current
								LegLabCur{iC} = sprintf('$%d\\to%d$',ii,jj);
								iC = iC+1;
							end
						end
					end
					% resize ax and add top axis for current!
					h.ax.Position(4) = h.ax.Position(4)/2;
					box on;
 					pl1 = plot(obj.t(1:obj.lastIdx)*ts,rhoDiag, plotOpt{:},'Displayname',obj.LegLabel);
					h.ax2 = axes('Position',h.ax.Position);
					h.ax2.Position(2) = h.ax2.Position(2)+h.ax2.Position(4);
					pl2 = plot(obj.t(1:obj.lastIdx)*ts,rhoCur, plotOpt{:},'Displayname',obj.LegLabel);
% 					ax2.XTickLabel = [];
					h.ax2.XAxisLocation = 'top';
					h.ax2.YAxisLocation = 'right';
					ylabel('Im($\rho_{ij})$')
					pl = [pl1;pl2];
					set(pl,{'Displayname'},[LegLabD,LegLabCur]');
					h.ylbl = '$\rho_{ii}$';
					axes(h.ax);
				case 'rho-dpmes'
					% Plots rhoii, rhoij-real and rhoij-imag stacked in 3 axes
					% start explicitely new figure?
					LegLabij = {'LE$^- \leftrightarrow $TT','CT$^+ \leftrightarrow $LE$^+$','CT$^- \leftrightarrow $TT','CT$^- \leftrightarrow $LE$^-$'};
					
					% rhoii:
					h.ax(1).Position(4) = h.ax(1).Position(4)/3;
					hsub = obj.plot('rhoii',h.ax(1),varargin{:});
					legend('TT','LE$^+$','LE$^-$','CT$^+$','CT$^-$');
					h.ylbl = '$\rho_{ii}$';
					col = {hsub.pl.Color};
					grid on;
					axis tight;
					% rhoij-real:
					h.ax(2) = axes('Position',h.ax(1).Position); hold all;
					h.ax(2).Position(2) = h.ax(2).Position(2)+h.ax(2).Position(4);
					hsub = obj.plot('rhoij-real',h.ax(2),varargin{:});
					h.ax(2).XTickLabels = '';
					h.ax(2).YTick = h.ax(2).YTick(2:end);
					xlabel('');
					hsub.pl([1,3,5,7,8,10]).delete;
					set(hsub.pl([2,4,6,9]),{'Color'},col(1:4)');			% reset color order
					grid on;
					axis tight;
					h.ax(2).YLim = h.ax(2).YLim + [-1,1]*0.1*abs(diff(h.ax(2).YLim));
					
					% rhoij-imag:
					h.ax(3) = axes('Position',h.ax(2).Position); hold all;
					h.ax(3).Position(2) = h.ax(3).Position(2)+h.ax(3).Position(4);
					hsub = obj.plot('rhoij-imag',h.ax(3),varargin{:});
					h.ax(3).XTickLabels = '';
					h.ax(3).YTick = h.ax(3).YTick(2:end);
					xlabel('');
					hsub.pl([1,3,5,7,8,10]).delete;
					set(hsub.pl([2,4,6,9]),{'Color'},col(1:4)');			% reset color order
					leg = legend(LegLabij{:});
					leg.Position = [0.4,0.6,0.14,0.15];
					grid on;
					axis tight;
					h.ax(3).YLim = h.ax(3).YLim + [-1,1]*0.1*abs(diff(h.ax(3).YLim));
					axes(h.ax(1));						% select first axis again
				case 'rhoii-ft'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					rhoii = obj.getData('rhoii');		% t x nStates
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
					h.ylbl = '$FT(\rho_{ii})$';
				case 'rhoii-osc-res'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					if isempty(obj.rhoOscRes)
						obj.rhoOscRes = obj.getData('rhoii-osc-res');		% t x nStates
					end
					rhoii = obj.rhoOscRes;
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
					h.ylbl = '$FT(\rho_{ii})$';
				case 'rhoii-osc-res-med'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					if isempty(obj.rhoOscRes)
						obj.rhoOscRes = obj.getData('rhoii-osc-res-med');		% t x nStates
					end
					rhoii = obj.rhoOscRes;
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					h.xdata = f;
					h.ydata = abs(ft);
					h.ylbl = '$FT(\rho_{ii})$';
				case 'rhoii-osc-res-mean'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					if isempty(obj.rhoOscRes)
						obj.rhoOscRes = obj.getData('rhoii-osc-res-mean');		% t x nStates
					end
					rhoii = obj.rhoOscRes;
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					h.xdata = f;
					h.ydata = abs(ft);
					h.ylbl = '$FT(\rho_{ii})$';
				case 'vne'
					% von Neumann Entropy of the system
					box on;
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = obj.getData('vne');				% t x 1
					h.leglbl = arrayfun(@(i) sprintf('$%d$',i),(1:size(h.ydata,2))','UniformOutput',false);
					h.ylbl = '$S_{vNE}(t)$';
				case 'chain-n-rc'
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = squeeze(real(obj.occC(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.leglbl = arrayfun(@(i) sprintf('$%d$',i),(1:size(h.ydata,2))','UniformOutput',false);
					h.ylbl = '$\langle n \rangle$';
				case 'chain-n-site2-ft'
					% applies DFT to the occupation of site 2
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
					maxN = pow2(nextpow2(20*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					h.data = squeeze(real(obj.occC(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.data = TDVPData.movAvgRes(h.data,350/obj.dt);
					ft = fft(real(h.data).*(window*ones(1,size(h.data,2))),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					h.xdata = f;
					h.ydata = abs(ft).^2;
					h.ylbl = '$FFT(\left< n_k \right>)$';
					h.tlbl = 'Chain Occupation Site 2 Fourier';
				case 'chain-n-rc-ft'
					% applies DFT to the occupation of site 2
					DFTplot = 1;
					h.data = real(squeeze(real(obj.occC(1:obj.lastIdx,2,:))));		% t x L x nChain
					h.data = TDVPData.movAvgRes(h.data,350/obj.dt);
					h.tdata = obj.t;
					h.Fs = 1/diff(obj.t(1:2));
					h.window = 'kaiser';
					h.zeroPadFact = 100;
					h.reassign = 1;
					h = TDVPData.FFT(h);
					f = h.xdata;
					h.ylbl = '$FFT(\left< n_k \right>)$';
					h.tlbl = 'Chain Occupation Site 2 Fourier';
				case 'chain-n-rc-tft'
					% applies DFT to the occupation of site 2
					DFTplot = 1;
					h.data = real(squeeze(real(obj.occC(1:obj.lastIdx,2,:))));		% t x L x nChain
					h.data = TDVPData.movAvgRes(h.data,350/obj.dt);
					h.tdata = obj.t;
					h.Fs = 1/diff(obj.t(1:2));
					h.window = 'kaiser';
					h.zeroPadFact = 100;
					h.reassign = 1;
					h = TDVPData.tFFT(h);
					f = h.xdata;
					h.ylbl = '$FFT(\left< n_k \right>)$';
					h.tlbl = 'Chain Occupation Site 2 Fourier';
				case 'chain-x-rc'
					h.xdata = obj.t(1:obj.lastIdx)*ts;
					h.ydata = squeeze(real(obj.xC(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.leglbl = arrayfun(@(i) sprintf('$%d$',i),(1:size(h.ydata,2))','UniformOutput',false);
					h.ylbl = '$\langle n \rangle$';
				case 'chain-x-site2-ft'
					% applies DFT to the occupation of site 2
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
					maxN = pow2(nextpow2(20*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					h.data = squeeze(real(obj.xC(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.data = TDVPData.movAvgRes(h.data,760/obj.dt);
					ft = fft(real(h.data).*(window*ones(1,size(h.data,2))),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					h.xdata = f;
					h.ydata = abs(ft);
					h.ylbl = '$FFT(\left< x_k \right>)$';
					h.tlbl = 'Chain Displacement Site 2 Fourier';
				case 'chain-x2-site2-ft'
					% applies DFT to the occupation of site 2
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
					maxN = pow2(nextpow2(20*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					h.data = squeeze(real(obj.xC2(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.data = TDVPData.movAvgRes(h.data,760/obj.dt);
					ft = fft(real(h.data).*(window*ones(1,size(h.data,2))),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					h.xdata = f;
					h.ydata = abs(ft);
					h.ylbl = '$FFT(\left< n_k \right>)$';
					h.tlbl = 'Chain Displacement squared Site 2 Fourier';
				case 'hshi'
					pl = plot(obj.t(1:obj.lastIdx)*ts,[obj.tresults.hshi(1:obj.lastIdx,:),sum(obj.tresults.hshi(1:obj.lastIdx,:),2)]);
					h.ylbl = '$\left< H_i \right>$';
				case 'stateproj'
					pl = plot(obj.t(1:obj.lastIdx)*ts, [abs(obj.stateProj(1:obj.lastIdx)),real(obj.stateProj(1:obj.lastIdx)),imag(obj.stateProj(1:obj.lastIdx))]);
					h.ylbl = 'Autocorrelation';
				case 'chain-x-t-avg'
					hold all;
					h.ydata = squeeze(sum(real(obj.xC(1:obj.lastIdx,:,:,:)),3));		% t x L x  nChain
					h.ydata = permute(h.ydata,[1 3 2]);				% t x state x L x chain
					pl = plot(obj.t(1:obj.lastIdx)*ts,h.ydata(:,:,2));
					h.ylbl = '$\left< x_k \right>$';					
				case 'linabs'
					% linear absorption as DFT of stateProj autocorrelation function
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
% 					m = 5000;
					maxN = m;
% 					maxN = pow2(nextpow2(1*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					linAbs = fft(conj(obj.stateProj(1:m)),maxN);	% do conj to get positive real part!
					if DFTshift
						linAbs = fftshift(linAbs);
						f = f-f(end)/2;
					end
% 					pl = plot(f, [real(linAbs),imag(linAbs),abs(linAbs)]);
					pl = plot(f, real(linAbs));
					h.ylbl = 'Linear Absorption';
				otherwise
					error('TDVPData:plot','PlotType not avaliable');
			end
			
			if ~isempty(h.ydata)
				if h.normalise
					h.ydata = bsxfun(@rdivide,h.ydata,max(h.ydata,[],1));
				end
				h.pl = plot(h.xdata, h.ydata);
				pl = h.pl;
			end
			if ~isempty(pl) && isempty(h.pl)
				h.pl = pl;
			end
			
			if h.distribute
				if  h.normalise
					% distribute across one axis
					for kk = 1:length(h.pl)
						set(h.pl(kk),'ydata', h.pl(kk).YData+length(h.pl)-kk);
					end
				else
					% create axis for each plot
					N = length(h.pl);
					heightTot = h.ax.Position(4);
					heightSingle = heightTot/N;
					h.ax.Position(4) = heightSingle;
					tempDel = h.pl(2:end);				% temphandle for deletion
					box on; axis tight;
					% from bottom to top:
% 					for i = 2:N							% from bottom to top
% 						h.ax(i) = axes; box on; axis tight;
% 						h.ax(i).Position([1,3,4,2]) = [h.ax(i-1).Position([1,3,4]),sum(h.ax(i-1).Position([2,4]))];
% 						h.ax(i).XTickLabel = '';
% 						h.pl(i) = copyobj(h.pl(i),h.ax(i));
% 				end
% 					axes(h.ax(1));
					% from top to bottom
					h.ax.Position(2) = h.ax.Position(2)+h.ax.Position(4)*(N-1);			% shift first plot to the top
					for i = 2:N
						h.ax(i) = axes; box on; axis tight;
						h.ax(i).Position([1,3,4,2]) = [h.ax(i-1).Position([1,3,4]),-diff(h.ax(i-1).Position([2,4]))];
						h.ax(i).XTickLabel = '';
						h.pl(i) = copyobj(h.pl(i),h.ax(i));
					end
					h.ax(N).XTickLabelMode = 'auto';
					h.ax(1).XTickLabel = '';
					tempDel.delete();
				end
			end
			
			if all(size(h.pl) == size(h.leglbl))
				set(h.pl,{'Displayname'},h.leglbl);
			end
			
			if DFTplot == 1
				if ts ~= 1
					f = f/0.658;
				end
				if eScale == 1
					f = f*4.135; % in eV
					h.xlbl = '$E/eV$';
				elseif eScale == 2
					f = f*4.135*8065.73; % in cm
				elseif eScale == 3
					f = 1239.84193./(f*4.135);		% in nm: hc/(E in eV);
				end
				for k = 1:length(h.pl)
					h.pl(k).XData = f(1:length(h.pl(k).XData));
				end
			end
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			if unicolor
				arrayfun(@(x) set(x,'Color',pl(1).Color), pl);
				h.ax.ColorOrderIndex = idx + 1;
			end
			
% 			figure; plot(obj.t(1:obj.lastIdx)*ts,abs(rhoii(1:obj.lastIdx,:)).*(window*ones(1,size(rhoii,2))));		% auxiliary plot for hann-windowed rhoii-ft
		end
		
		function h   = plotSld1D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			% default: Plot versus time
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logY = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (obj.t(1:obj.lastIdx)*h.ts).';
			h.ydata = [];				% T x L x NC x ...  if not, needs to be reshaped!
			h.noSldDims = 1;			% default: only plot 1 dim
			h.xSize = length(h.xdata)*ones(1,obj.nChains);
			
			h.xlbl = '$t$';
			h.ylbl = '';
			h.tlbl = '';
			
			h.f  = [];
			h.ax = [];
			
			for m = 1:nargin-2
				if isobject(varargin{m})
					if isa(varargin{m},'matlab.ui.Figure')
						h.f  = varargin{m};
					elseif isa(varargin{m},'matlab.graphics.axis.Axes')
						h.ax = varargin{m};
					end
					continue;
				end
					
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.xlbl = '$t/fs$';
						h.xdata = h.xdata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logY = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			if isempty(h.f)
				if isempty(h.ax)
					h.f = figure();
				else
					axes(h.ax);					% select axes
					h.f = gcf;					% get their figure
				end
			end
			if isempty(h.ax)
				h.ax = gca;
			end
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
				
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
% 			if ~isempty(strfind(lower(type),'star'))
% 				% need to find lengths of chains in star picture -> length of x-axis
% 				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
% % 					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
% 				else
% % 					h.xSize = size(obj.omega,1)*ones(1,h.nChains);
% 				end
% 			end
			
			switch lower(type)
				case 'chain-n-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t';
				case 'chain-n-d-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occCd(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t - diabatic';
				case 'chain-n-a-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occCa(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t - adiabatic';
				case 'chain-n-c-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occCc(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t - coherence';
				case 'chain-n-k'
					% Plot n(k), slider in t & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ydata = permute(h.ydata,[2,1,3]);					% L x t x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.xdata = (1:obj.para.L).';
					h.xSize = obj.para.L*ones(1,obj.nChains);
					h.xlbl = 'Site $k$';
					h.sldlbl = {'Time t =','Chain'};
					h.tlbl = 'Chain Occupation vs k';
				case 'chain-x-t'
					h.ydata = real(obj.xC(1:obj.lastIdx,:,:,:));		% t x L  x nChain
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-d-t'
					h.ydata = real(obj.xCd(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement - diabatic';
				case 'chain-x-a-t'
					h.ydata = real(obj.xCa(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement - adiabatic';
				case 'chain-x-c-t'
					h.ydata = abs(obj.xCc(1:obj.lastIdx,:,:,:));		% t x L x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x chain x L
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k ='};
					h.tlbl = 'Chain Displacement - coherence';
				case 'chain-x2-t'
					h.ydata = real(obj.xC2(1:obj.lastIdx,:,:,:));		% t x L  x nChain
					h.ylbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement squared';
				case 'chain-x2-d-t'
					h.ydata = real(obj.xC2d(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement squared - diabatic';
				case 'chain-x-t-avg'
					hold all;
					h.ydata = squeeze(sum(real(obj.xC(1:obj.lastIdx,:,:,:)),3));		% t x L x  nChain
					h.ydata = permute(h.ydata,[1 3 2]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k ='};
					h.tlbl = 'Chain Displacement';
				case 'star-n-t'
					h.ydata = real(obj.occS(1:obj.lastIdx,:,:));		% t x w x nChain
					h.yPlots = 1;
					h.ylbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x-t'
					hold all;
					h.ydata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x w x chain
					h.noSldDims = 2;									% first 2 dims without Slider
					h.ylbl = '$\left< f_k \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Displacement';
				case 'state'
					hold all;
					h.ydata = obj.sysState(1:obj.lastIdx,:,:).*conj(obj.sysState(1:obj.lastIdx,:,:));			% t x dk x D; calc the probability
					h.ydata = permute(h.ydata,[1,3,2]);
					h.ydata(:,end+1,:) = sum(h.ydata,2);
					h.ylbl = '$|\Psi_k|^2$';
					h.noSldDims = 2;
					h.tlbl = 'Adiabatic State evolution';
					h.sldlbl = {'State #'};
				case 'state-adiab'
					hold all;
					h.ydata = obj.sysState(1:obj.lastIdx,:,:).*conj(obj.sysState(1:obj.lastIdx,:,:));			% t x dk x D; calc the probability
					h.ydata(:,end+1,:) = sum(h.ydata,2);
					h.ylbl = '$|\Psi_k|^2$';
					h.noSldDims = 2;
					h.tlbl = 'Adiabatic State evolution';
					h.sldlbl = {'Bond #'};
				otherwise
					return;
			end
			
			h.f.Name = h.tlbl;
			
			if h.logY
				h.ydata = sign(h.ydata) .* log10(abs(h.ydata));
				h.ylbl = ['$\log_{10}',h.ylbl(2:end)];
			end
			
			h.nSld = ndims(h.ydata)-h.noSldDims;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);					% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			
			if h.noSldDims == 1
				h.pl{1} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,h.SldIdx{:}));
			elseif h.noSldDims == 2
				hold all;
				for ii = 1:size(h.ydata,2)
					h.pl{ii} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,ii,h.SldIdx{:}));
				end
			end
			axis tight
			grid on
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.ysize(h.noSldDims+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_1D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_1D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
				for kk = 1:length(h.pl)
					if length(h.pl) == 1
						set(h.pl{1} ,'ydata', h.ydata(:,h.SldIdx{:}));
					else
						set(h.pl{kk},'ydata', h.ydata(:,kk,h.SldIdx{:}));
					end
				end
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function [h,pl]   = plotSld1DFT(obj, type, varargin)
			%% Plot with Slider to change DFT range and window / padding
			% No slider in dataset here. Only in DFT parameters
			% default: Plot versus freq
			if length(obj) > 1
				% deal with object array
				pl = gobjects(length(obj),1);
				for ii = 1:length(obj)
					[hTemp,temp] = obj(ii).plotSld1DFT(type,varargin{:});
					temp = reshape(temp,1,[]);
					if size(pl,2) ~= size(temp,2)
						pl(end,size(temp,2)) = gobjects(1,1);
					end
					pl(ii,:) = temp;
					h(ii) = hTemp;
				end
				return;
			end	
			h = struct();				% struct containing all infos & handles
			h.freqScale = 1;			% scale freq axis
			h.fInvert = 0;				% need 1/f for nm scale?
			h.logY = 0;					% linear y-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.normalise = 0;
			h.distribute = 0;			% distribute plot lines along y; only use if h.normalise = 1, otherwise gets messy
			h.smoothRes = 0;			% apply to residual after smoothing?
			h.meanRes = 0;				% apply to residual after mean
			h.xdata = obj.t(1:obj.lastIdx).';	% the time axis
			h.ydata = [];				% T x L x NC x ...  if not, needs to be reshaped!
			h.noSldDims = 1;			% default: only plot 1 dim
			h.xSize = length(h.xdata)*ones(1,obj.nChains);
			
			
			h.xlbl = '$f$';
			h.ylbl = '';
			h.tlbl = '';
			h.llbl = {};
			
			h.f  = [];
			h.ax = [];
			
			% FFT settings
			h.data = [];								% FFT done in 1st dimension
			h.dataRange = obj.lastIdx;					% last (real) datapoint to include
			h.zeroPadFactor = 4;						% multiples of dataset to pad
			h.power2 = 1;								% FFT in power of 2?
			h.useWindowFcn = 1;							% whether to use the (1) Hann or (2) Kaiser window function
			h.FFTshift = 0;
			
			for m = 1:nargin-2
				if isobject(varargin{m})
					if isa(varargin{m},'matlab.ui.Figure')
						h.f  = varargin{m};
					elseif isa(varargin{m},'matlab.graphics.axis.Axes')
						h.ax = varargin{m};
					end
					continue;
				end
				if isnumeric(varargin{m})
					continue;
				end
				switch lower(varargin{m})
					case '-ev'
						% ev scale for H in eV
						h.freqScale = h.freqScale/0.658*4.135;
						h.xlbl = '$E/eV$';
					case '-cmev'
						% use cm^-1 as Units
						h.freqScale = h.freqScale/0.658*4.135*8065.73;
						h.xlbl = '$E/cm^{-1}$';
					case '-nmev'
						% nm scale, H in ev
						h.freqScale = h.freqScale/0.658*4.135/1239.84193;
						h.fInvert = 1;
						h.xlbl = '$\lambda/nm$';
					case '-log'
						% Logarithmic scale in z
						h.logY = 1;
					case '-fftshift'
						h.FFTshift = 1;
					case '-norm'
						h.normalise = 1;
					case '-dist'
						h.distribute = 1;
					case '-smoothres'
						if nargin-2 > m && isnumeric(varargin{m+1})
							h.smoothRes = varargin{m+1};
						else
							h.smoothRes = 1;
						end
					case '-meanres'
						h.meanRes = 1;
					case '-kaiser'
						h.useWindowFcn = 2;
				end
			end
			
			% Create figure handles and panels
			if isempty(h.f)
				if isempty(h.ax)
					h.f = figure();
				else
					axes(h.ax);					% select axes
					h.f = gcf;					% get their figure
				end
			end
			if isempty(h.ax)
				h.ax = gca;
			end
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.cP_width = 150;						% control Panel width
			h.f.Position(3) = h.f.Position(3)+h.cP_width;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-h.cP_width,1,h.cP_width,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			% define dataset for FFT
			switch lower(type)
				case 'linabs'
					% linear absorption as DFT of stateProj autocorrelation function
					h.data = conj(obj.stateProj(1:obj.lastIdx));
					h.useWindowFcn = 0;								% needs to be switched off!!
				case 'rhoii'
					% applies DFT to the population probability of rho
					rhoii = gettRhoiiSystem(obj);		% t x nStates
					h.data = real(rhoii(1:obj.lastIdx,:));
					h.noSldDims = 2;					% plot 2nd dim simultaneously
				case 'rhoii-osc-res'
					rhoii = obj.getData('rhoii-osc-res');
					h.data = rhoii;
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
				case 'rhoij-imag'
					r = obj.getData('rhoij');							% {rhoij, info}
					h.llbl = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					h.data = imag(r{1});
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
				case 'chain-n'
					h.data = squeeze(real(obj.occC(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.ylbl = '$FFT(\left< n_k \right>)$';
					h.tlbl = 'Chain Occupation Site 2 Fourier';
					h.llbl = arrayfun(@(i) sprintf('Chain $%d$',i),(1:size(h.data,2))','UniformOutput',false);
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
				case 'chain-x2'
					h.data = squeeze(real(obj.xC2(1:obj.lastIdx,2,:)));		% t x L x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.tlbl = 'Chain displacement squared Site 2 Fourier';
					h.llbl = arrayfun(@(i) sprintf('Chain $%d$',i),(1:size(h.data,2))','UniformOutput',false);
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
				otherwise
					warning('TDVPData:plotSld1DFT','Plot type not existent!');
					return;
			end
			
			if h.smoothRes == 1
				h.data = TDVPData.movAvgRes(h.data,760/obj.dt);					% 170: 300cm or 350: 145cm or 760: 66cm accuracy
			elseif h.smoothRes ~= 0
				h.data = TDVPData.movAvgRes(h.data,h.smoothRes/obj.dt);					% 170: 300cm or 350: 145cm or 760: 66cm accuracy
			end
			
			if h.meanRes == 1
				h.data = TDVPData.meanRes(h.data);
			end
			
			calcFFT();				% fills h.ydata with FFT
			
			h.f.Name = h.tlbl;
			
			if h.logY
				h.ydata = sign(h.ydata) .* log10(abs(h.ydata));
				h.ylbl = ['$\log_{10}',h.ylbl(2:end)];
			end
			
			if ~isvector(h.ydata)
				h.nSld = 2+ndims(h.ydata)-h.noSldDims;				% number of sliders needed; +1 for DFT
			else
				h.nSld = 2;
			end
			h.ysize = size(h.data);
			h.sldlbl = {'tMax','nPad'};
			h.sldInitVal= [h.ysize(1),0];
			h.sldLimits = [1,h.ysize(1); 0, 100];					% [min1, max1; min2, max2; ...]
			h.SldIdx = num2cell(ones(1,h.nSld),1);					% indices for each slider dimension, indicating currently displayed slice
			
			h.pl = plot(h.xdata, plotSpec());		% plotspec returns the actual data from h.ydata type-specific
			if ~isempty(h.llbl)
				set(h.pl,{'DisplayName'},h.llbl);					% h.llbl needs to be same shape as h.pl
			end
			
			if h.distribute
				if  ~h.normalise
					% create axis for each plot
					N = length(h.pl);
					heightTot = h.ax.Position(4);
					heightSingle = heightTot/N;
					h.ax.Position(4) = heightSingle;
					tempDel = h.pl(2:end);				% temphandle for deletion
% 					box on; axis tight;
					% from bottom to top:
% 					for i = 2:N							% from bottom to top
% 						h.ax(i) = axes; box on; axis tight;
% 						h.ax(i).Position([1,3,4,2]) = [h.ax(i-1).Position([1,3,4]),sum(h.ax(i-1).Position([2,4]))];
% 						h.ax(i).XTickLabel = '';
% 						h.pl(i) = copyobj(h.pl(i),h.ax(i));
% 					end
% 					axes(h.ax(1));
					% from top to bottom
					h.ax.Position(2) = h.ax.Position(2)+h.ax.Position(4)*(N-1);			% shift first plot to the top
					for i = 2:N
						h.ax(i) = axes; box on; axis tight;
						h.ax(i).Position([1,3,4,2]) = [h.ax(i-1).Position([1,3,4]),-diff(h.ax(i-1).Position([2,4]))];
						h.ax(i).XTickLabel = '';
						h.pl(i) = copyobj(h.pl(i),h.ax(i));
					end
					h.ax(N).XTickLabelMode = 'auto';
					h.ax(1).XTickLabel = '';
					tempDel.delete();
				end
			end
			
			axis tight
			grid on
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			% Create Slider(s) inside h.controlPanel
			h.cP_padIn = 5;		% controlPanel padding inside
			h.sld_w = (h.cP_width-h.cP_padIn); h.sld_h = 20;
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax(1).FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,h.sldInitVal(ii),1,h.sldLimits(ii,1),h.sldLimits(ii,2)+1);									%JScrollBar(int orientation, int value, int extent, int min, int max)
				h.SldIdx{ii} = h.sldInitVal(ii)-1;
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(round(diff(h.sldLimits(ii,:))/100)); h.sld{ii}.setBlockIncrement(round(diff(h.sldLimits(ii,:))/10));
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_1D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			
			posDisplay();
			callback_1D_Sld();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			pl = h.pl;
			
			function callback_1D_Sld(source, callbackdata, n)
				% Callback for 1D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				if nargin > 0
					h.SldIdx{n} = round(source.Value);
					h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
					h.dataRange = h.SldIdx{1};
					h.zeroPadFactor = h.SldIdx{2};
					calcFFT();
				end
				out = plotSpec();
				for kk = 1:length(h.pl)
					if length(h.pl) == 1
						set(h.pl(1) ,'xdata',h.xdata,'ydata', out);
					else
						if h.normalise && h.distribute
							set(h.pl(kk),'xdata',h.xdata,'ydata', out(:,kk)+length(h.pl)-kk);
						else
							set(h.pl(kk),'xdata',h.xdata,'ydata', out(:,kk));
						end
					end
				end
			end
			
			function calcFFT()
				% performs the FFT. Will be called after each slider adjustment
				maxN = h.dataRange*(1+h.zeroPadFactor);
				if h.power2
					maxN = pow2(nextpow2(maxN));
				end
				h.xdata = (0:maxN-1)/obj.t(2)/maxN;			% get frequency
				if h.useWindowFcn
					if h.useWindowFcn == 1
						window = hann(h.dataRange,'periodic');
					elseif h.useWindowFcn == 2
						window = kaiser(h.dataRange,2.5);
					end
					h.ydata = fft(h.data(1:h.dataRange,:).*(window*ones(1,size(h.data,2))),maxN,1);				% do FFT in 1st dimension
				else
					h.ydata = fft(h.data,maxN,1);			% do FFT in 1st dimension
				end
				if h.FFTshift
					h.ydata = fftshift(h.ydata,1);			% shift to have -f/2 : f/2
					h.xdata = h.xdata - h.xdata(end)/2;
				end
				h.xdata = h.xdata * h.freqScale;
				if h.fInvert
					h.xdata = 1./h.xdata;					% necessary for wavelength plots
				end
				h.xSize = length(h.xdata);
			end
			
			function out = plotSpec()
				% define, which components of the DFT will be plotted, real imag or abs
				switch lower(type)
					case 'linabs'
						% linear absorption as DFT of stateProj autocorrelation function
						out = [real(h.ydata),imag(h.ydata)];
					case 'rhoii'
						% applies DFT to the population probability of rho
						out = abs(h.ydata);
					case 'rhoii-osc-res'
						% applies DFT to the residual of the populations of rho
						out = abs(h.ydata);
					case 'rhoij-imag'
						out = abs(h.ydata);
					case 'chain-n'
						out = abs(h.ydata);
					case 'chain-x2'
						out = abs(h.ydata);
					otherwise
						warning('TDVPData:plotSld1DFT','Plot type not existent!');
						return;
				end
				if h.normalise
					out = bsxfun(@rdivide,out,max(out,[],1));
				end
			end
			
			function posDisplay(varargin)
				if isvalid(h.sldText{1})
					for kk = 1:h.nSld
						h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
						h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
					end
				end
			end
			
		end
		
		function h   = plotSld2D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logZ = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (1:obj.para.L).';
			h.ydata = obj.t(1:obj.lastIdx)*h.ts;
			h.zdata = [];					% T x L x NC x ...  if not, needs to be reshaped!
			h.xSize = obj.para.L*ones(1,obj.nChains);	% size for each slider value
			
			if obj.nChains > 1 && obj.para.useTreeMPS
				h.xSize = cellfun(@(x) x.L,obj.para.chain)+1;
				h.xdata = (1:max(h.xSize))'*ones(1,obj.nChains);
			end
			
			h.xlbl = 'Site $k$';
			h.ylbl = '$t$';
			h.zlbl = '';
			h.tlbl = '';
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.ylbl = '$t/fs$';
						h.ydata = h.ydata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logZ = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			if ~isempty(strfind(lower(type),'star'))
				% need to find lengths of chains in star picture -> length of x-axis
% 				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
% 					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
% 				else
					h.xSize = size(obj.omega,1)*ones(1,obj.nChains);
					h.ydata = obj.tS;
					h.ySize = length(h.ydata);
% 				end
			end
			
			switch lower(type)
				case 'chain-n'
					h.zdata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Occupation';
				case 'chain-n-d'
					h.zdata = real(obj.occCd(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Occupation - diabatic';
				case 'chain-n-a'
					h.zdata = real(obj.occCa(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Occupation - adiabatic';
				case 'chain-x'
					h.zdata = real(obj.xC(1:obj.lastIdx,:,:));			% t x L x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-d'
					h.zdata = real(obj.xCd(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement - diabatic';
				case 'chain-x-a'
					h.zdata = real(obj.xCa(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement - adiabatic';
				case 'chain-x-avg'
					h.zdata = squeeze(sum(real(obj.xCa(1:obj.lastIdx,:,:,:)),3));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-ft'
					h.maxN = pow2(nextpow2(obj.lastIdx));				% FT window length
					h.ydata = (0:h.maxN/2)/h.ydata(end);				% fs * k/N = k/T where k=0... N/2
					h.ylbl = '$f$ in $1/fs$';
					if h.evTocm && h.ts ~=1
						h.ydata = h.ydata*4.135*8065.73;
						h.ylbl = '$f/cm^{-1}$';
					end
					h.zdata = fft(real(obj.xC(1:obj.lastIdx,:,:,:)),h.maxN,1);		% f x L x state x chain
					h.zdata = 2*abs(h.zdata(1:h.maxN/2+1,:,:,:));
					h.zlbl = '$FT(\left< x_k \right>)$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x2'
					h.zdata = real(obj.xC2(1:obj.lastIdx,:,:));			% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement squared';
				case 'chain-x2-d'
					h.zdata = real(obj.xC2d(1:obj.lastIdx,:,:,:));		% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement squared - diabatic';
				case 'chain-x2-a'
					h.zdata = real(obj.xC2a(1:obj.lastIdx,:,:,:));		% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement squared - adiabatic';
				case 'chain-x-unc'										% uncertainty in x
					x = real(obj.xC(1:obj.lastIdx,:,:));
					x2 = real(obj.xC2(1:obj.lastIdx,:,:));
					h.zdata = sqrt(x2-x.^2);							% t x L x chain
					h.zdata(:,1,:) = h.zdata(:,1,:) + 0.5;				% balance spin site
					h.zlbl = '$\Delta x_k$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement - uncertainty';
				case 'star-n'
					h.zdata = real(obj.occS(1:h.ySize,:,:));			% t x w x nChains
					h.zlbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x'
					h.zdata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.zlbl = '$\left< f_k \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Star Displacement';
				case 'state-adiab'
					h.zdata = obj.sysState(1:obj.lastIdx,:,:).*conj(obj.sysState(1:obj.lastIdx,:,:));			% t x dk x D; calc the probability
					h.zlbl = '$|\Psi_k|^2$';
					h.xlbl = 'Diabatic States';
					h.xdata = (1:size(obj.sysState,2)).';
					h.xSize = size(obj.sysState,2)*ones(1,obj.nChains);
					h.tlbl = 'Adiabatic State evolution';
					h.sldlbl = {'Bond State'};
					
			end
			h.f.Name = h.tlbl;
			
			if h.logZ
				h.zdata = sign(h.zdata) .* log10(abs(h.zdata));
				h.zlbl = ['$\log_{10}',h.zlbl(2:end)];
			end
			
			h.nSld = ndims(h.zdata)-2;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			h.zsize = size(h.zdata);
			
			h.pl = surf(h.xdata(1:h.xSize(1),1),h.ydata,h.zdata(:,1:h.xSize(1),h.SldIdx{:}));
			shading interp
			rotate3d on
			axis tight
			h.ax.View = [0 90];
			h.ax.TickDir = 'out';
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			zlabel(h.zlbl);
			h.cb = colorbar; h.cb.Title.Interpreter = 'latex';
			h.cb.Title.String = h.zlbl;

			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.zsize(2+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				if size(h.xdata,2) > 1 && size(h.xdata,2) == size(h.zdata,n+2)
					% high probability that current slider is going through chains
					mc = round(source.Value);
					set(h.pl,'xdata', h.xdata(1:h.xSize(mc),mc));
					set(h.pl,'zdata', h.zdata(:,1:h.xSize(mc),h.SldIdx{:}));
					h.ax.CLim = h.ax.ZLim;
				else
					xs = length(get(h.pl,'xdata'));
					set(h.pl,'zdata', h.zdata(:,1:xs,h.SldIdx{:}));
					h.ax.CLim = h.ax.ZLim;
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSldBloch(obj, type, varargin)
			h = struct();
			h.xlbl = '$\left<sigma_x\right>$';
			h.ylbl = '$\left<sigma_y\right>$';
			h.zlbl = '$\left<sigma_z\right>$';
			h.tlbl = '';
			h.linewidth = 5;
			if isempty(obj.rho)
				error('need reduced density matrix for this function!');
			end
			assert(size(obj.rho,2) == 2, 'Can only do this for 2-lvl systems right now');
			
			% Observables to compute
			[sigmaX,sigmaY,sigmaZ] = spinop('Z');
			h.sigmaX = reshape(sigmaX.',[],1);
			h.sigmaY = reshape(sigmaY.',[],1);
			h.sigmaZ = reshape(sigmaZ.',[],1);
			
			% reshape rho into convenient shape
			h.d = size(obj.rho);		% t x i x j x k (states)
			if length(h.d) == 4
				h.Nstates = h.d(4);
				h.rho = reshape(obj.rho,h.d(1),[],h.d(4));
				h.sv = zeros(h.d(1),h.Nstates-1);
				h.tlbl = 'Adiabatic Spin evolution';
			else
				h.Nstates = 1;
				h.rho = reshape(obj.rho,h.d(1),[]);
				h.sv = [];			% not used since no sv existing
				h.tlbl = 'Spin Evolution';
			end
			
			for ii = 2:h.Nstates
				% extract the SV^2 to plot bloch vectors with correct length
				h.sv(:,ii-1) = real(diag(squeeze(h.rho(:,:,1))*squeeze(h.rho(:,:,ii))'));	% achieves the same
			end
			
			h.xdata = zeros(h.d(1),h.Nstates);
			h.xsize = size(h.xdata);
			h.ydata = zeros(h.d(1),h.Nstates);
			h.ysize = size(h.ydata);
			h.zdata = zeros(h.d(1),h.Nstates);
			h.zsize = size(h.zdata);
			for ii = 1:h.Nstates
				% compute <sigma> of all rho
				h.xdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaX);
				h.ydata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaY);
				h.zdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaZ);
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.f.Name = h.tlbl;
			h.ax = gca; hold all;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
% 			set(h.f,'DefaultLineLineWidth',h.linewidth);
			h.ax.Color = 'none';

			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			% Slider options
			h.nSld = 1;					% Use slider only in t
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.sldlbl = {'Time'};
			
			% Create Plot for t = 0
			h.sphereon = true;
			if h.sphereon
				sphere
				daspect([1 1 1])
				alpha(0.2)
% 				h.ax.Children.Linestyle = ':';			% thinner mesh
				set(get(gca,'children'),'linestyle',':','linewidth',0.5)
			end
% 			scatter3(tresults.spin.sx,tresults.spin.sy,tresults.spin.sz,20,'filled');
			h.pl = cell(h.Nstates,1);
			for ii = 1:h.Nstates
				if ii == 1
% 					h.pl{ii} = plot3([0,h.xdata(h.SldIdx{:},ii)],[0,h.ydata(h.SldIdx{:},ii)],[0,h.zdata(h.SldIdx{:},ii)]);
					h.pl{ii} = quiver3(0,0,0,h.xdata(h.SldIdx{:},ii),h.ydata(h.SldIdx{:},ii),h.zdata(h.SldIdx{:},ii),1,...
								'LineWidth',h.linewidth);
				else
					h.pl{ii} = quiver3(0,0,0,0,0,0,1,'LineWidth',h.linewidth*0.5);
% 					h.pl{ii} = plot3([0,0],[0,0],[0,0],'LineWidth',h.linewidth*0.5);		% dummy initialise! assume always pure initial state
				end
			end
			h.ax.XLim = [-1,1];
			h.ax.YLim = [-1,1];
			h.ax.ZLim = [-1,1];
			h.ax.View = [-29,16];
			rotate3d on
			
			%
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld		% only have 1 slider!!
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.xsize(1)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				tt = round(source.Value);
				for kk = 1:h.Nstates
					if kk == 1
						% update the full vector
						h.pl{1}.UData = h.xdata(tt,1);
						h.pl{1}.VData = h.ydata(tt,1);
						h.pl{1}.WData = h.zdata(tt,1);
					else
						% update the part vectors
						% get their origin from the previous vector
						if kk == 2
% 							x0 = 0; y0 = 0; z0 = 0;
							% do nothing
						else
							% set origin to end of previous quiver
							h.pl{kk}.XData = h.pl{kk-1}.XData+h.pl{kk-1}.UData;
							h.pl{kk}.YData = h.pl{kk-1}.YData+h.pl{kk-1}.VData;
							h.pl{kk}.ZData = h.pl{kk-1}.ZData+h.pl{kk-1}.WData;
						end
						% calculate their destination point
						h.pl{kk}.UData = h.xdata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.VData = h.ydata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.WData = h.zdata(tt,kk)*h.sv(tt,kk-1);
% 						set(h.pl{kk},'xdata', [x0,x1]);
% 						set(h.pl{kk},'ydata', [y0,y1]);
% 						set(h.pl{kk},'zdata', [z0,z1]);
					end
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function out = chainParaInfo(obj)
			% returns the parameters of each chain.
			out = [];
			for ii = 1:obj.para.nChains
				out(ii).xi = obj.para.chain{ii}.xi;
				out(ii).Gamma = obj.para.chain{ii}.Gamma;
				out(ii).epsilon = obj.para.chain{ii}.epsilon;
				out(ii).t = obj.para.chain{ii}.t;
			end
		end
		
		function exportCSV(obj,type,loc,varargin)
			% function used for exporting dataset of 'type' in obj-array to location loc: cell array
			%
			if length(obj) > 1
				for ii = 1:length(obj)
					obj(ii).exportCSV(type,loc{ii});
				end
				return;
			end
			
			% from now: loc is a string, obj is single object
			
			switch lower(type)
				case 'sz'
					x = reshape(obj.t(1:obj.lastIdx),[],1);
					y = reshape(obj.tresults.spin.sz(1:obj.lastIdx),[],1);
					out = [x,y];
				case 'chain-n'
					x = reshape(1:obj.para.L,[],1);
					y = reshape(obj.t(1:obj.lastIdx),[],1);
					z = obj.occC(1:obj.lastIdx,:,1);
					out = [0,x';y,z];
				case 'star-n'
					x = reshape(obj.omega,[],1);
					y = reshape(obj.tS,[],1);
					z = obj.occS(:,:,1);								% t x w x nChains
					% only pick first chain for now.
					out = [0,x';y,z];
				case 'star-x'
					x = reshape(obj.omega,[],1);
					y = reshape(obj.tS,[],1);
					z = real(obj.xS(:,:,1));								% t x w x nChains
					% only pick first chain for now.
					out = [0,x';y,z];
				otherwise
					error('Dataset type not supported yet!');
			end
			dir = fileparts(loc);
			if ~exist(dir,'dir')
				mkdir(dir);
			end
			csvwrite(loc,out);
			
        end
        
        function out = getSysEnvObs(obj,type,varargin)
			%% function out = getSysEnvObs(obj,type,varargin)
			%	Contract the environment states with an operator specified by
			%	type:
			%	 'n' : occupation
			%    'x' : displacement
			%
			%	Only for bosons on the 2nd site for now.
			%	
			%	out: NC x 1 cell
			%		with Op_(r',r) right observable containing the contracted operator
			NC = obj.para.nChains;
			out = cell(obj.lastIdx, NC);		% t x NC
			for mc = 1:NC
				% compute for all times simultaneously
				dk = cellfun(@(x) size(x{mc},1), obj.Vmat(1:obj.lastIdx,2));	% dk(t)
				bp = arrayfun(@(x) bosonop(x,0,'n'),dk,'UniformOutput',false);
				switch lower(type)
					% select the appropriate operator
					case 'n'
						op = cellfun(@(x) x*x', bp,'UniformOutput',false);
					case 'x'
						op = cellfun(@(x) (x+x')./2, bp,'UniformOutput',false);
				end
				out(:,mc) = arrayfun(@(t) updateCright([],obj.mps{t,2}{mc}, obj.Vmat{t,2}{mc},op{t},obj.mps{t,2}{mc}, obj.Vmat{t,2}{mc}),...
					(1:obj.lastIdx)','UniformOutput',false);
				
			end
		end
		
		function obj = getSpin(obj)
			h = struct();
			% Observables to compute
			[sigmaX,sigmaY,sigmaZ] = spinop('Z');
			h.sigmaX = reshape(sigmaX.',[],1);
			h.sigmaY = reshape(sigmaY.',[],1);
			h.sigmaZ = reshape(sigmaZ.',[],1);
			
			% reshape rho into convenient shape
			h.d = size(obj.rho);		% t x i x j x k (states)
			if length(h.d) == 4
				h.Nstates = h.d(4);
				h.rho = reshape(obj.rho,h.d(1),[],h.d(4));
				h.sv = zeros(h.d(1),h.Nstates-1);
				h.tlbl = 'Adiabatic Spin evolution';
			else
				h.Nstates = 1;
				h.rho = reshape(obj.rho,h.d(1),[]);
				h.sv = [];			% not used since no sv existing
				h.tlbl = 'Spin Evolution';
			end
			
			obj.spin = zeros(obj.lastIdx,3,h.Nstates,'single');
			for ii = 1:h.Nstates
				% compute <sigma> of all rho
				obj.spin(:,1,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaX);
				obj.spin(:,2,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaY);
				obj.spin(:,3,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaZ);
			end
		end
	end
	
	% Static methods are functions that do not require 'obj' but are
    % relevant to methods that do.
	% Also some helper functions
    % They are called using TDVPData.myFun()
    methods(Static = true)
		function foldLib = getTDVPLib()
			filePattern = '20*\results-Till*.mat';
			foldLib = [rdir(['..\TDVP\',filePattern]);rdir(['..\TDVP\Data\',filePattern]);rdir(['..\cacheComputations\',filePattern]);...
				       rdir(['..\TDVP-Git\',filePattern]);rdir(['..\TDVP-Git\Data\',filePattern])];
			% remove 'incomplete' files
			foldLib = foldLib(arrayfun(@(x) isempty(strfind(x.name,'incomplete')),foldLib));
		end
		
		function matches = getMatches(lib, dirPat, filPat)
			%% function matches = getMatches(lib, dirPat, filPat)
			%	find files with regexp
			matches = lib(arrayfun(@(x) ~isempty(regexp(x.name,[dirPat,'\\',filPat],'once')),lib));
		end
		
		function B = movAvg(A,m)
			%% function A = movAvg(A,m)
			%	computes the moving average with window size m
			%	smooth along first dimension
			d = size(A);
			B = reshape(A,d(1),[]);
			for i = 1:size(B,2)
				B(:,i) = smooth(B(:,i),m,'moving');
			end
% 			figure(); hold all
% 			plot(reshape(A,d(1),[]),'b')
% 			plot(B,'r')
			B = reshape(B,d);
		end
		
		function B = movAvgRes(A,m)
			%% function A = movAvgRes(A,m)
			%	computes the residual of a moving average with window size m
			B = A - TDVPData.movAvg(A,m);
		end
		
		function B = meanRes(A)
			%% function B = meanRes(A,m)
			%	subtracts the mean along the first dimension
			B = bsxfun(@minus,A,mean(A,1));
		end
		
		function h = plotGrid(rows,cols,f)
			%% function h = plotGrid(rows,cols)
			%	creates a grid of axes
			%	onto a 8.5 cm x 6.4 cm figure
			if nargin >= 3
				h.f = f;
				figure(h.f);
				clf;
			else
				h.f = figure();
			end
			h.rows = rows;
			h.cols = 1;			% TODO: extend for more columns
			
			% important measures:
				% 2016a: ax.Position = [1.1041   0.70432   6.5822   5.2184]   for only left and bottom axis label
			h.axW = 7.2; h.axH = 1; h.axdX = 0; h.axdY = 0; h.axdYgroup = 0.3;	% maximum sizes and default paddings between axes
			
			% Pre-process axes
			h.f.Units = 'centimeters'; h.f.Position([3,4]) = [8.5,1+h.axH*h.rows];
			% f.Renderer = 'painters';
			set(h.f,'DefaultAxesFontSize', 8,...
					'DefaultLineLineWidth',1);
			% Lowest 
			i=h.rows; h.ax(i) = axes; box on;
			xlabel('xlabel');ylabel('ylabel');
			h.ax(i).Units = 'centimeters'; h.ax(i).Position([2,3,4]) = [0.9,h.axW,h.axH];

			for i = (h.rows-1):-1:1
				h.ax(i) = axes; box on;
				h.ax(i).Units = 'centimeters'; h.ax(i).Position([1,3,4,2]) = [h.ax(i+1).Position([1,3,4]),sum(h.ax(i+1).Position([2,4]))];
				h.ax(i).XTickLabel = '';
			end

			[h.ax.Units] = deal('norm');
		end
		
		function h = plotRowGroups(rows,f)
			%% function h = plotRowGroups(rows[,f])
			%	creates rows of axes
			%	onto a 8.5 cm x ? cm figure
			%	rows = [5,7]
			%		gives 2 groups of rows
			if nargin >= 2
				h.f = f;
				figure(h.f);
				clf;
			else
				h.f = figure();
			end
			h.rows = rows;
			h.split = rows(1:end-1);	% which axes have to be shifted upwards for the split
			% important measures:
				% 2016a: ax.Position = [1.1041   0.70432   6.5822   5.2184]   for only left and bottom axis label
			h.axW = 7.2; h.axH = 1; h.axdX = 0; h.axdY = 0; h.axdYgroup = 0.3;	% maximum sizes and default paddings between axes
			
			% Pre-process axes
			h.f.Units = 'centimeters'; h.f.Position([3,4]) = [8.5,1+h.axH*sum(h.rows)+h.axdYgroup*(length(h.rows)-1)];
			% f.Renderer = 'painters';
			set(h.f,'DefaultAxesFontSize', 8,...
					'DefaultLegendInterpreter','latex',...
					'DefaultLineLineWidth',1);
			% Lowest 
			i=sum(h.rows); h.ax(i) = axes; box on;
			xlabel('xlabel');ylabel('ylabel');
			h.ax(i).Units = 'centimeters'; h.ax(i).Position([2,3,4]) = [0.9,h.axW,h.axH];

			for i = (sum(h.rows)-1):-1:1
				h.ax(i) = axes; box on;
				h.ax(i).Units = 'centimeters'; h.ax(i).Position([1,3,4,2]) = [h.ax(i+1).Position([1,3,4]),sum(h.ax(i+1).Position([2,4]))];
				h.ax(i).XTickLabel = '';
				if any(i == h.split)
					h.ax(i).Position(2) = h.ax(i).Position(2)+h.axdYgroup;		% shift upwards for group split
				end
			end

			[h.ax.Units] = deal('norm');
			movegui(h.f,'center');
		end
		
		function h = FFT(h)
			%% function h = FFT(h)
			%	performs the FFT using the periodogram function
			%	h.data = x;		-> h.ydata = FFT(x)
			%	h.tdata = t;	-> h.xdata = freq
			if ~isfield(h,'reassign')
				h.reassign = 0;
			end
			if ~isfield(h,'window')
				h.window = '';
			end
			if ~isfield(h,'zeroPadFact')
				h.zeroPadFact = 0;
			end
			assert(length(h.tdata) == size(h.data,1),'FFT input has wrong dimensions');
			
			h.m = length(h.tdata);
			
			if strcmp(h.window,'hann')
				h.wind = hann(h.m,'periodic');
			elseif strcmp(h.window,'kaiser')
				h.wind = kaiser(h.m,5);
			else
				h.wind = [];
			end
			
			if h.reassign
				[pre,ft,pxx,fc] = periodogram(h.data,h.wind,pow2(nextpow2((1+h.zeroPadFact)*h.m)),h.Fs,'power','reassigned');
% 				h.xdata = fc;		% center-of-mass frequencies, plots only for stem()
				h.xdata = ft;
				h.ydata = pre;
			else
				[pxx,f] = periodogram(h.data,h.wind,pow2(nextpow2((1+h.zeroPadFact)*h.m)),h.Fs,'power');
				h.xdata = f;
				h.ydata = pxx;
			end
			
		end
		
		function h = tFFT(h)
			%% function h = tFFT(h)
			%	performs the time-resolved FFT using the spectrogram function
			%	h.data = x;		-> h.ydata = FFT(x)
			%	h.tdata = t;	-> h.xdata = freq
			if ~isfield(h,'reassign')
				h.reassign = 0;
			end
			if ~isfield(h,'window')
				h.window = '';
			end
			if ~isfield(h,'zeroPadFact')
				h.zeroPadFact = 0;
			end
			assert(length(h.tdata) == size(h.data,1),'FFT input has wrong dimensions');
			
			h.m = length(h.tdata);
			
			if strcmp(h.window,'hann')
				h.wind = hann(h.m,'periodic');
			elseif strcmp(h.window,'kaiser')
				h.wind = kaiser(h.m,5);
			else
				h.wind = [];
			end
			
			if h.reassign
								  spectrogram(h.data(:,4),kaiser(1024,5),1000,(h.m*7),10,'reassigned','power','MinThreshold',-40)
				[pre,ft,pxx,fc] = spectrogram(h.data,h.wind,pow2(nextpow2((1+h.zeroPadFact)*h.m)),h.Fs,'power','reassigned');
% 				h.xdata = fc;		% center-of-mass frequencies, plots only for stem()
				h.xdata = ft;
				h.ydata = pre;
			else
				[pxx,f] = spectrogram(h.data,h.wind,pow2(nextpow2((1+h.zeroPadFact)*h.m)),h.Fs,'power');
				h.xdata = f;
				h.ydata = pxx;
			end
			
		end
	end
	
end