classdef TDVPData
	% The 'TDVPData' class is used to load, process and analyze data
	% generated by VMPS/TDVP code
    %
	
	% Defines all properties of objects from class 'TDVPData'.
    % They are accessed by objName.property
    properties
		tCalc;		% t of the simulation
		dt;			% timesteps
		t;			% t of observables
		tS;			% t of star extraction
		omega;		% frequency axis for star picture
		para;
		tresults;
		version;
		nChains;
		% for SBM:
		alpha;		% if Spin-Boson
		s;			% if Spin-Boson
		lastIdx     % last Observable Idx
		occC;		% chain occupation
		occS;		% star occupation
		xC;			% chain displacement
		xS;			% star displacement
		jC;			% chain current
		rho;		% rduced density matrix
		stateProj;	% state projection amplitude
		LegLabel;	%
		Comment;	% 
	end
	
	methods
			
		
		function obj = TDVPData(fname,varargin)
			% obj = TDVPData(para,tresults)
			%
			% Load TDVP dataset into a TDVPData object
			if nargin > 1
				if isstruct(fname) && isstruct(varargin{1})
					temp.para = fname;
					temp.tresults = varargin{1};
				else
					fprintf('please program me\n');
				end
			end
			if nargin == 0
				return;		% empty initialization
			end
			if nargin == 1 && ischar(fname)
				try
					temp = load(fname,'para','tresults');
					% Deserialize if needed
					Vars = fields(temp);
					for ii = 1:size(Vars)
						x = temp.(Vars{ii});
						if isa(x,'uint8')
							temp.(Vars{ii}) = hlp_deserialize(x);
	% 						eval(sprintf('%s = hlp_deserialize(%s);',Vars(ii).name,Vars(ii).name));
						end
					end
				catch err
					fprintf('load failed for: %s\n',fname);
					return;
				end
			end
			
			% assign parameters
			if isfield(temp, 'para') && isfield(temp,'tresults')
				obj.para = temp.para;
				obj.tresults = temp.tresults;
			end
			obj.version = str2double(obj.para.tdvp.version(2:end));
			
			if obj.version >= 50
				obj.occC = obj.tresults.n;
			else
				obj.occC = real(obj.tresults.nx);
			end
			
			if obj.version >= 66 && isfield(obj.tresults,'x')
				obj.xC = obj.tresults.x;
			end
			
			if obj.version >= 42
				obj.t = obj.tresults.t;
			else
				obj.t = obj.para.tdvp.t;
			end
			obj.tCalc = obj.para.tdvp.t;
			obj.dt    = obj.para.tdvp.deltaT;
			
			if isfield(obj.para,'nChains')
				obj.nChains = obj.para.nChains;
			else
				obj.nChains = 1;
			end
			
			if isfield(obj.tresults,'rho')
				obj.rho = obj.tresults.rho;
			else
				obj.rho = [];
			end
			
			obj.lastIdx = obj.tresults.lastIdx;
			
			% save star observables
			if isfield(obj.tresults,'star')
				if isfield(obj.tresults.star,'n')
					obj.occS  = obj.tresults.star.n;
				else
					obj.occS = 0;
				end
				if isfield(obj.tresults.star,'x')
					obj.xS    = obj.tresults.star.x;
				else
					obj.xS = 0;
				end
				obj.tS    = obj.tresults.star.t;
				if size(obj.tresults.star.omega,1) ~= 1
					obj.omega = obj.tresults.star.omega;		% w x nChains
				else
					obj.omega = obj.tresults.star.omega.';		% w x 1
				end
			end
			
			% extract simulation parameters SBM
			if ~isempty(strfind(obj.para.model,'SpinBoson'))
				if isa(obj.para.chain,'struct')
					if isfield(obj.para,'alpha')
						obj.alpha = obj.para.alpha;
					end
					if isfield(obj.para,'s')
						obj.s = obj.para.s;
					end

				elseif isa(obj.para.chain,'cell')
					obj.alpha = cellfun(@(x) x.alpha, obj.para.chain);
					obj.s     = cellfun(@(x) x.s    , obj.para.chain);
				end
			end
			
			if isfield(obj.tresults,'stateProjection')
				obj.stateProj = obj.tresults.stateProjection;
			end
			
			if ~isempty(strfind(obj.para.model,'DPMES'))
				% any particular vars for DPMES?
			end
			obj.LegLabel = '';
		end
		
		function obj = setLegLabel(obj,entry)
			if ~isa(entry,'string')
				obj.LegLabel = num2str(entry);
			else
				obj.LegLabel = varName;
			end
		end
		
		function obj = setComment(obj, str)
			obj.Comment = str;
		end
		
		function out = gettRhoiiSystem(obj)
			% returns the diagonal of the system reduced density matrix
			out = 0;
			if isfield(obj.tresults,'PPCWavefunction')
				out = obj.tresults.PPCWavefunction;
			elseif isfield(obj.tresults,'rho')
				out = cell2mat(arrayfun(@(i) diag(squeeze(obj.tresults.rho(i,:,:))),1:size(obj.tresults.rho,1),'UniformOutput',false)).';
			end
		end
		
		function out = getData(obj,type,varargin)
			% returns certain data or observables
			full = 0;		% truncate to simulated time - tresults.lastIdx
			idxOffset = 0;
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-full'
						full = 1;
				end
			end
			
			switch lower(type)
				case 'calctime'
					out = obj.para.tdvp.calcTime;
					idxOffset = 1;
				case 'calctime-d'
					out = diff(obj.para.tdvp.calcTime);
					idxOffset = 2;
			end
			
			if ~full
				out = out(1:obj.tresults.lastIdx-idxOffset);	% truncate if wanted
			end
		end
		
		function pl  = plot(obj,type,varargin)
			% initialise modifiers
			% plot(...,ax_handle)	Plots into the axes given by handle
			ts = 1;						% scale time axis
			eScale = 0;					% energy units used for DFT: 0 = none, 1 = eV, 2 = cm (wavenumber)
			unicolor = 0;
			resetColorOrder = 0;		% start from index 1
			plotOpt = {};				% additional plotOptions from varargin
			DFTplot = 0;				% plotting DFT data
			DFTshift = 0;				% shift the fft results
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV and eV scale in DFT plots
						ts = 0.658;
						eScale = 1;
					case '-cmev'
						% cm scale in DFT plots
						ts = 0.658;
						eScale = 2;
					case '-nmev'
						% nm scale in DFT plots
						ts = 0.658;
						eScale = 3;
					case '-fftshift'
						DFTshift = 1;
					case '-unicol'
						% same colors on all lines
						unicolor = 1;
					case '-resetcolororder'
						resetColorOrder = 1;
					otherwise
						% pass through as direct plot options!
						if isa(varargin{m},'matlab.graphics.axis.Axes')
							axes(varargin{m});
						else
							plotOpt = [plotOpt, varargin(m)];
						end
				end
			end
			
			ax = gca;
			
			if resetColorOrder
				ax.ColorOrderIndex = 1;
			end
			
			if unicolor
				idx = ax.ColorOrderIndex;
			end
			
			switch lower(type)
				case 'sz'
					pl = plot(obj.t(1:obj.lastIdx)*ts, obj.tresults.spin.sz(1:obj.lastIdx));
				case 'calctime'
					pl = plot(obj.t(2:obj.lastIdx)*ts,obj.para.tdvp.calcTime(1:obj.lastIdx-1),'Displayname',obj.LegLabel);
				case 'calctime-d'
					% 1st derivative, in hours
					pl = plot(obj.t(2:obj.lastIdx-1)*ts,diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1)),'Displayname',obj.LegLabel);
				case 'calctime-d-sec'
					% 1st derivative, in seconds
					pl = plot(obj.t(2:obj.lastIdx-1)*ts,3600*diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1)),'Displayname',obj.LegLabel);
				case 'rhoii'
					rhoii = gettRhoiiSystem(obj);
					pl = plot(obj.t(1:obj.lastIdx)*ts,abs(rhoii(1:obj.lastIdx,:)), plotOpt{:},'Displayname',obj.LegLabel);
				case 'hshi'
					pl = plot(obj.t(1:obj.lastIdx)*ts,[obj.tresults.hshi(1:obj.lastIdx,:),sum(obj.tresults.hshi(1:obj.lastIdx,:),2)]);
				case 'stateproj'
					pl = plot(obj.t(1:obj.lastIdx)*ts, [abs(obj.stateProj(1:obj.lastIdx)),real(obj.stateProj(1:obj.lastIdx)),imag(obj.stateProj(1:obj.lastIdx))]);
				case 'linabs'
					% linear absorption as DFT of stateProj autocorrelation function
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
% 					maxN = m*10;%15000;
					maxN = pow2(nextpow2(m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					linAbs = fft(conj(obj.stateProj(1:m)),maxN);	% do conj to get positive real part!
					if DFTshift
						linAbs = fftshift(linAbs);
						f = f-f(end)/2;
					end
					pl = plot(f, [real(linAbs),imag(linAbs)]);
				case 'rhoii-ft'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
% 					maxN = m*2;
					maxN = pow2(nextpow2(m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					rhoii = gettRhoiiSystem(obj);		% t x nStates
					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
			end
			
			if DFTplot == 1
				if ts ~= 1
					f = f/0.658;
				end
				if eScale == 1
					f = f*4.135; % in eV
				elseif eScale == 2
					f = f*4.135*8065.73; % in cm
				elseif eScale == 3
					f = 1239.84193./(f*4.135);		% in nm: hc/(E in eV);
				end
				for k = 1:length(pl)
					pl(k).XData = f(1:length(pl(k).XData));
				end
			end
			
			if unicolor
				arrayfun(@(x) set(x,'Color',pl(1).Color), pl);
				ax.ColorOrderIndex = idx + 1;
			end
		end
		
		function h   = plotSld1D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			% default: Plot versus time
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logY = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (obj.t(1:obj.lastIdx)*h.ts).';
			h.ydata = [];				% T x L x NC x ...  if not, needs to be reshaped!
			h.noSldDims = 1;			% default: only plot 1 dim
			h.xSize = length(h.xdata)*ones(1,obj.nChains);
			
			h.xlbl = '$t$';
			h.ylbl = '';
			h.tlbl = '';
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.xlbl = '$t/fs$';
						h.xdata = h.xdata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logY = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
% 			if ~isempty(strfind(lower(type),'star'))
% 				% need to find lengths of chains in star picture -> length of x-axis
% 				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
% % 					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
% 				else
% % 					h.xSize = size(obj.omega,1)*ones(1,h.nChains);
% 				end
% 			end
			
			switch lower(type)
				case 'chain-n-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t';
				case 'chain-n-k'
					% Plot n(k), slider in t & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ydata = permute(h.ydata,[2,1,3]);					% L x t x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.xdata = (1:obj.para.L).';
					h.xSize = obj.para.L*ones(1,obj.nChains);
					h.xlbl = 'Site $k$';
					h.sldlbl = {'Time t =','Chain'};
					h.tlbl = 'Chain Occupation vs k';
				case 'chain-x-t'
					hold all;
					h.ydata = real(obj.xC(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'star-n-t'
					h.ydata = real(obj.occS(1:obj.lastIdx,:,:));		% t x w x nChain
					h.yPlots = 1;
					h.ylbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x-t'
					hold all;
					h.ydata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x w x chain
					h.noSldDims = 2;									% first 2 dims without Slider
					h.ylbl = '$\left< f_k \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Displacement';
			end
			
			h.f.Name = h.tlbl;
			
			if h.logY
				h.ydata = sign(h.ydata) .* log10(abs(h.ydata));
				h.ylbl = ['$\log_{10}',h.ylbl(2:end)];
			end
			
			h.nSld = ndims(h.ydata)-h.noSldDims;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);					% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			
			if h.noSldDims == 1
				h.pl{1} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,h.SldIdx{:}));
			elseif h.noSldDims == 2
				for ii = 1:size(h.ydata,2)
					h.pl{ii} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,ii,h.SldIdx{:}));
				end
			end
			axis tight
			grid on
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.ysize(h.noSldDims+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_1D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_1D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
				for kk = 1:length(h.pl)
					if length(h.pl) == 1
						set(h.pl{1} ,'ydata', h.ydata(:,h.SldIdx{:}));
					else
						set(h.pl{kk},'ydata', h.ydata(:,kk,h.SldIdx{:}));
					end
				end
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSld2D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logZ = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (1:obj.para.L).';
			h.ydata = obj.t(1:obj.lastIdx)*h.ts;
			h.zdata = [];					% T x L x NC x ...  if not, needs to be reshaped!
			h.xSize = obj.para.L*ones(1,obj.nChains);
			
			h.xlbl = 'Site $k$';
			h.ylbl = '$t$';
			h.zlbl = '';
			h.tlbl = '';
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.ylbl = '$t/fs$';
						h.ydata = h.ydata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logZ = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			if ~isempty(strfind(lower(type),'star'))
				% need to find lengths of chains in star picture -> length of x-axis
				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
				else
					h.xSize = size(obj.omega,1)*ones(1,obj.nChains);
				end
			end
			
			switch lower(type)
				case 'chain-n'
					h.zdata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Occupation';
				case 'chain-x'
					h.zdata = real(obj.xC(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-ft'
					h.maxN = pow2(nextpow2(obj.lastIdx));				% FT window length
					h.ydata = (0:h.maxN/2)/h.ydata(end);					% fs * k/N = k/T where k=0... N/2
					h.ylbl = '$f$ in $1/fs$';
					if h.evTocm && h.ts ~=1
						h.ydata = h.ydata*4.135*8065.73;
						h.ylbl = '$f/cm^{-1}$';
					end
					h.zdata = fft(real(obj.xC(1:obj.lastIdx,:,:,:)),h.maxN,1);		% f x L x state x chain
					h.zdata = 2*abs(h.zdata(1:h.maxN/2+1,:,:,:));
					h.zlbl = '$FT(\left< x_k \right>)$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'star-n'
					h.zdata = real(obj.occS(1:obj.lastIdx,:,:));		%
					h.zlbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x'
					h.zdata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.zlbl = '$\left< f_k \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Star Displacement';
			end
			h.f.Name = h.tlbl;
			
			if h.logZ
				h.zdata = sign(h.zdata) .* log10(abs(h.zdata));
				h.zlbl = ['$\log_{10}',h.zlbl(2:end)];
			end
			
			h.nSld = ndims(h.zdata)-2;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			h.zsize = size(h.zdata);
			
			h.pl = surf(h.xdata(1:h.xSize(1),1),h.ydata,h.zdata(:,1:h.xSize(1),h.SldIdx{:}));
			shading interp
			rotate3d on
			axis tight
			h.ax.View = [0 90];
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			zlabel(h.zlbl);
			h.cb = colorbar; h.cb.Title.Interpreter = 'latex';
			h.cb.Title.String = h.zlbl;

			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.zsize(2+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				if size(h.xdata,2) > 1 && size(h.xdata,2) == size(h.zdata,n+2)
					% high probability that current slider is going through chains
					mc = round(source.Value);
					set(h.pl,'xdata', h.xdata(1:h.xSize(mc),mc));
					set(h.pl,'zdata', h.zdata(:,1:h.xSize(mc),h.SldIdx{:}));
				else
					xs = length(get(h.pl,'xdata'));
					set(h.pl,'zdata', h.zdata(:,1:xs,h.SldIdx{:}));
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSldBloch(obj, type, varargin)
			h = struct();
			h.xlbl = '$\left<sigma_x\right>$';
			h.ylbl = '$\left<sigma_y\right>$';
			h.zlbl = '$\left<sigma_z\right>$';
			h.tlbl = '';
			h.linewidth = 5;
			if isempty(obj.rho)
				error('need reduced density matrix for this function!');
			end
			assert(size(obj.rho,2) == 2, 'Can only do this for 2-lvl systems right now');
			
			% Observables to compute
			[sigmaX,sigmaY,sigmaZ] = spinop('Z');
			h.sigmaX = reshape(sigmaX.',[],1);
			h.sigmaY = reshape(sigmaY.',[],1);
			h.sigmaZ = reshape(sigmaZ.',[],1);
			
			% reshape rho into convenient shape
			h.d = size(obj.rho);		% t x i x j x k (states)
			if length(h.d) == 4
				h.Nstates = h.d(4);
				h.rho = reshape(obj.rho,h.d(1),[],h.d(4));
				h.sv = zeros(h.d(1),h.Nstates-1);
				h.tlbl = 'Adiabatic Spin evolution';
			else
				h.NStates = 1;
				h.rho = reshape(obj.rho,h.d(1),[]);
				h.sv = [];			% not used since no sv existing
				h.tlbl = 'Spin Evolution';
			end
			
			for ii = 2:h.Nstates
				% extract the SV^2 to plot bloch vectors with correct length
				h.sv(:,ii-1) = real(diag(squeeze(h.rho(:,:,1))*squeeze(h.rho(:,:,ii))'));	% achieves the same
			end
			
			h.xdata = zeros(h.d(1),h.Nstates);
			h.xsize = size(h.xdata);
			h.ydata = zeros(h.d(1),h.Nstates);
			h.ysize = size(h.ydata);
			h.zdata = zeros(h.d(1),h.Nstates);
			h.zsize = size(h.zdata);
			for ii = 1:h.Nstates
				% compute <sigma> of all rho
				h.xdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaX);
				h.ydata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaY);
				h.zdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaZ);
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.f.Name = h.tlbl;
			h.ax = gca; hold all;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
% 			set(h.f,'DefaultLineLineWidth',h.linewidth);
			h.ax.Color = 'none';

			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			% Slider options
			h.nSld = 1;					% Use slider only in t
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.sldlbl = {'Time'};
			
			% Create Plot for t = 0
			h.sphereon = true;
			if h.sphereon
				sphere
				daspect([1 1 1])
				alpha(0.2)
% 				h.ax.Children.Linestyle = ':';			% thinner mesh
				set(get(gca,'children'),'linestyle',':','linewidth',0.5)
			end
% 			scatter3(tresults.spin.sx,tresults.spin.sy,tresults.spin.sz,20,'filled');
			h.pl = cell(h.Nstates,1);
			for ii = 1:h.Nstates
				if ii == 1
% 					h.pl{ii} = plot3([0,h.xdata(h.SldIdx{:},ii)],[0,h.ydata(h.SldIdx{:},ii)],[0,h.zdata(h.SldIdx{:},ii)]);
					h.pl{ii} = quiver3(0,0,0,h.xdata(h.SldIdx{:},ii),h.ydata(h.SldIdx{:},ii),h.zdata(h.SldIdx{:},ii),1,...
								'LineWidth',h.linewidth);
				else
					h.pl{ii} = quiver3(0,0,0,0,0,0,1,'LineWidth',h.linewidth*0.5);
% 					h.pl{ii} = plot3([0,0],[0,0],[0,0],'LineWidth',h.linewidth*0.5);		% dummy initialise! assume always pure initial state
				end
			end
			h.ax.XLim = [-1,1];
			h.ax.YLim = [-1,1];
			h.ax.ZLim = [-1,1];
			h.ax.View = [-29,16];
			rotate3d on
			
			%
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld		% only have 1 slider!!
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.xsize(1)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				tt = round(source.Value);
				for kk = 1:h.Nstates
					if kk == 1
						% update the full vector
						h.pl{1}.UData = h.xdata(tt,1);
						h.pl{1}.VData = h.ydata(tt,1);
						h.pl{1}.WData = h.zdata(tt,1);
					else
						% update the part vectors
						% get their origin from the previous vector
						if kk == 2
% 							x0 = 0; y0 = 0; z0 = 0;
							% do nothing
						else
							% set origin to end of previous quiver
							h.pl{kk}.XData = h.pl{kk-1}.XData+h.pl{kk-1}.UData;
							h.pl{kk}.YData = h.pl{kk-1}.YData+h.pl{kk-1}.VData;
							h.pl{kk}.ZData = h.pl{kk-1}.ZData+h.pl{kk-1}.WData;
						end
						% calculate their destination point
						h.pl{kk}.UData = h.xdata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.VData = h.ydata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.WData = h.zdata(tt,kk)*h.sv(tt,kk-1);
% 						set(h.pl{kk},'xdata', [x0,x1]);
% 						set(h.pl{kk},'ydata', [y0,y1]);
% 						set(h.pl{kk},'zdata', [z0,z1]);
					end
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function out = chainParaInfo(obj)
			% returns the parameters of each chain.
			out = [];
			for ii = 1:obj.para.nChains
				out(ii).xi = obj.para.chain{ii}.xi;
				out(ii).Gamma = obj.para.chain{ii}.Gamma;
				out(ii).epsilon = obj.para.chain{ii}.epsilon;
				out(ii).t = obj.para.chain{ii}.t;
			end
		end
	end
	
	% Static methods are functions that do not require 'obj' but are
    % relevant to methods that do.
	% Also some helper functions
    % They are called using TDVPData.myFun()
    methods(Static = true)
		function foldLib = getTDVPLib()
			filePattern = '20*\results-Till*.mat';
			foldLib = [rdir(['..\TDVP\',filePattern]);rdir(['..\TDVP\Data\',filePattern]);rdir(['..\cacheComputations\',filePattern]);...
				       rdir(['..\TDVP-Git\',filePattern]);rdir(['..\TDVP-Git\Data\',filePattern])];
			% remove 'incomplete' files
			foldLib = foldLib(arrayfun(@(x) isempty(strfind(x.name,'incomplete')),foldLib));
		end
		
		
		
	end
	
end