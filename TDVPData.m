classdef TDVPData
	% The 'TDVPData' class is used to load, process and analyze data
	% generated by VMPS/TDVP code
    %
	
	% Defines all properties of objects from class 'TDVPData'.
    % They are accessed by objName.property
    properties
		tCalc;		% t of the simulation
		dt;			% timesteps
		t;			% t of observables
		tS;			% t of star extraction
		omega;		% frequency axis for star picture
		para;
		tresults;
		version;
		nChains;
		% for SBM:
		alpha;		% if Spin-Boson
		s;			% if Spin-Boson
		lastIdx;    % last Observable Idx
		spin;		% Spin Observable
		occC;		% chain occupation
		occCd;		% chain occupation, diabatic projection
		occCa;		% chain occupation, adiabatic projection
		occS;		% star occupation
		xC;			% chain displacement
		xCd;		% chain displacement, diabatic projection
		xCa;		% chain displacement, adiabatic projection
		xC2;		% chain <x^2>
		xC2d;		% chain <x^2>, diabatic projection
		xC2a;		% chain <x^2>, adiabatic projection
		xS;			% star displacement
		jC;			% chain current
		rho;		% rduced density matrix
		rhoOscRes;	% residual of populations after exponential fit
		stateProj;	% state projection amplitude
		sysState;	% state of system
        mps;        % MPS and Vmat of sites 1&2
        Vmat;
		LegLabel;	%
		Comment;	% 
	end
	
	methods
			
		
		function obj = TDVPData(fname,varargin)
			% obj = TDVPData(para,tresults)
			%
			% Load TDVP dataset into a TDVPData object
			if nargin > 1
				if isstruct(fname) && isstruct(varargin{1})
					temp.para = fname;
					temp.tresults = varargin{1};
				else
					fprintf('please program me\n');
				end
			end
			if nargin == 0
				return;		% empty initialization
			end
			if nargin == 1 && ischar(fname)
				try
					temp = load(fname,'para','tresults');
					% Deserialize if needed
					Vars = fields(temp);
					for ii = 1:size(Vars)
						x = temp.(Vars{ii});
						if isa(x,'uint8')
							temp.(Vars{ii}) = hlp_deserialize(x);
	% 						eval(sprintf('%s = hlp_deserialize(%s);',Vars(ii).name,Vars(ii).name));
						end
					end
				catch err
					fprintf('load failed for: %s\n',fname);
					return;
				end
			end
			
			% assign parameters
			if isfield(temp, 'para') && isfield(temp,'tresults')
				obj.para = temp.para;
				obj.tresults = temp.tresults;
			end
			obj.version = str2double(obj.para.tdvp.version(2:end));
			
			if isfield(obj.tresults,'spin')
				obj.spin = zeros(obj.lastIdx,3,'single');				% t x 3
				obj.spin(:,1) = obj.tresults.spin.sx(1:obj.lastIdx);
				obj.spin(:,2) = obj.tresults.spin.sy(1:obj.lastIdx);
				obj.spin(:,3) = obj.tresults.spin.sz(1:obj.lastIdx);
			end
			
			if obj.version >= 50 && isfield(obj.tresults,'n')
				obj.occC = obj.tresults.n;
			elseif isfield(obj.tresults,'nx')
				obj.occC = real(obj.tresults.nx);
			end
			if obj.version >= 72 && isfield(obj.tresults,'na')
				obj.occCa = obj.tresults.na;
				if isempty(obj.occC)
					obj.occC = squeeze(sum(real(obj.occCa),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'nd')
				obj.occCd = obj.tresults.nd;
				if isempty(obj.occC)
					obj.occC = squeeze(sum(real(obj.occCd),3));
				end
			end
			
			if obj.version >= 66 && isfield(obj.tresults,'x')
				if ndims(obj.tresults.x) == 3
					obj.xC = obj.tresults.x;
				elseif ~isempty(strfind(obj.para.tdvp.Observables,'.x.'))		% support for version <=72
					obj.xCd = obj.tresults.x;
					if isempty(obj.xC)
						obj.xC = squeeze(sum(real(obj.xCd),3));
					end
				elseif ~isempty(strfind(obj.para.tdvp.Observables,'.x2.'))		% support for version <=72
					obj.xCa = obj.tresults.x;
					if isempty(obj.xC)
						obj.xC = squeeze(sum(real(obj.xCd),3));
					end
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'xa')
				obj.xCa = obj.tresults.xa;
				if isempty(obj.xC)
					obj.xC = squeeze(sum(real(obj.xCa),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'xd')
				obj.xCd = obj.tresults.xd;
				if isempty(obj.xC)
					obj.xC = squeeze(sum(real(obj.xCd),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2')
				obj.xC2 = obj.tresults.x2;
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2a')
				obj.xC2a = obj.tresults.x2a;
				if isempty(obj.xC2)
					obj.xC2 = squeeze(sum(real(obj.xC2a),3));
				end
			end
			if obj.version >= 72 && isfield(obj.tresults,'x2d')
				obj.xC2d = obj.tresults.x2d;
				if isempty(obj.xC2)
					obj.xC2 = squeeze(sum(real(obj.xC2d),3));
				end
			end
			
			if obj.version > 42
				obj.t = obj.tresults.t;
			else
				obj.t = obj.para.tdvp.t;
			end
			obj.tCalc = obj.para.tdvp.t;
			obj.dt    = obj.para.tdvp.deltaT;
			
			if isfield(obj.para,'nChains')
				obj.nChains = obj.para.nChains;
			else
				obj.nChains = 1;
			end
			
			if isfield(obj.tresults,'rho')
				obj.rho = obj.tresults.rho;
			else
				obj.rho = [];
			end
			obj.rhoOscRes = [];
			
			if isfield(obj.tresults,'system') && isfield(obj.tresults.system,'state')
				obj.sysState = obj.tresults.system.state;
			else
				obj.sysState = [];
			end
			
			obj.lastIdx = obj.tresults.lastIdx;
			
			% save star observables
			if isfield(obj.tresults,'star')
				if isfield(obj.tresults.star,'n')
					obj.occS  = obj.tresults.star.n;
					if obj.version <= 42 && size(obj.occS,1) == length(obj.tresults.star.omega)
						obj.occS = obj.occS.';
					end
				else
					obj.occS = 0;
				end
				if isfield(obj.tresults.star,'x')
					obj.xS    = obj.tresults.star.x;
				else
					obj.xS = 0;
				end
				obj.tS    = obj.tresults.star.t;
				if size(obj.tresults.star.omega,1) ~= 1
					obj.omega = obj.tresults.star.omega;		% w x nChains
				else
					obj.omega = obj.tresults.star.omega.';		% w x 1
				end
			end
			
			% extract simulation parameters SBM
			if ~isempty(strfind(obj.para.model,'SpinBoson'))
				if isa(obj.para.chain,'struct')
					if isfield(obj.para,'alpha')
						obj.alpha = obj.para.alpha;
					end
					if isfield(obj.para,'s')
						obj.s = obj.para.s;
					end

				elseif isa(obj.para.chain,'cell')
					obj.alpha = cellfun(@(x) x.alpha, obj.para.chain);
					obj.s     = cellfun(@(x) x.s    , obj.para.chain);
				end
			end
			
			if isfield(obj.tresults,'stateProjection')
				obj.stateProj = obj.tresults.stateProjection;
			end
			
			if isfield(obj.tresults,'mps')
                obj.mps = obj.tresults.mps;
                obj.tresults.mps = [];
                obj.Vmat = obj.tresults.Vmat;
                obj.tresults.Vmat = [];
			end
			
			if ~isempty(strfind(obj.para.model,'DPMES'))
				% any particular vars for DPMES?
			end
			obj.LegLabel = '';
		end
		
		function obj = setLegLabel(obj,entry)
			if ~isa(entry,'string')
				obj.LegLabel = num2str(entry);
			else
				obj.LegLabel = varName;
			end
		end
		
		function obj = setComment(obj, str)
			obj.Comment = str;
		end
		
		function out = gettRhoiiSystem(obj)
			% returns the diagonal of the system reduced density matrix
			out = 0;
			if isfield(obj.tresults,'PPCWavefunction')
				out = obj.tresults.PPCWavefunction;
			elseif isfield(obj.tresults,'rho')
				out = cell2mat(arrayfun(@(i) diag(squeeze(obj.tresults.rho(i,:,:))),1:size(obj.tresults.rho,1),'UniformOutput',false)).';
			end
		end
		
		function out = getData(obj,type,varargin)
			% returns certain data or observables
			full = 0;		% truncate to simulated time - tresults.lastIdx
			idxOffset = 0;
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-full'
						full = 1;
				end
			end
			
			switch lower(type)
				case 'calctime'
					out = obj.para.tdvp.calcTime;
					idxOffset = 1;
				case 'calctime-d'
					out = diff(obj.para.tdvp.calcTime);
					idxOffset = 2;
				case 'rhoii-osc-res'
					% oscillating residuals
					plotFit = 1;						% 1: plot the fitted functions into separate figure to evaluate fitness.
					rhoii = abs(gettRhoiiSystem(obj));		% t x dk(1)
					rhoii = rhoii(1:obj.lastIdx,:);
					out = zeros(size(rhoii));
					% fit and remove exponential components to obtain the residuals
					if plotFit
						f = gcf;
						figure; hold all; ax = gca;
						plot(obj.t(1:obj.lastIdx),rhoii);
						ax.ColorOrderIndex = 1;					% reset to have fit in same color as original data
					end
					for m = 1:size(rhoii,2)
						fun{1} = @(x,xdata) x(1)+x(2).*exp(x(3).*xdata);					% exponential model with shift
						fun{2} = @(x,xdata) x(1)+x(2).*exp(x(3).*xdata)+x(4).*exp(x(5).*xdata);					% exponential model with shift
						a0{1} = double([rhoii(end,m),rhoii(1,m)-rhoii(end,m),-0.01]);								% initial guesses
						if rhoii(1,m) == 0
							a0{1}(3) = mean(diff(rhoii(100:200,m)))/obj.t(2);			% rise if starting from 0
						end
						a0{2} = double([rhoii(end,m),rhoii(1,m)-rhoii(end,m),-0.01,rhoii(1,m)-rhoii(end,m),+0.01]);								% initial guesses
						for k = 1:length(fun)
							[x{k},r(k),res{k}] = lsqcurvefit(fun{k},a0{k},double(obj.t(1:obj.lastIdx).'), double(rhoii(:,m)));
						end
						[~,ind] = min(r);		% pick function with minimal residual norm;
						if plotFit, plot(obj.t(1:obj.lastIdx),fun{ind}(x{ind},obj.t(1:obj.lastIdx))); end
						out(:,m) = res{ind};		% save the residual
					end
					if plotFit,	figure(f); end
					full = 1;
				case 'rhoii-osc-res-med'
					% oscillating residuals
					plotFit = 1;						% 1: plot the fitted functions into separate figure to evaluate fitness.
					rhoii = abs(gettRhoiiSystem(obj));		% t x dk(1)
					rhoii = rhoii(1:obj.lastIdx,:);
					out = zeros(size(rhoii));
					% fit by smoothing and remove exponential components to obtain the residuals
					if plotFit
						f = gcf;
						figure; hold all; ax = gca;
						plot(obj.t(1:obj.lastIdx),rhoii);
						ax.ColorOrderIndex = 1;					% reset to have fit in same color as original data
					end
% 					filtered = medfilt1(rhoii,1000,1);
					filtered = zeros(size(rhoii));
					for kk = 1:size(rhoii,2)
						filtered(:,kk) = smooth(rhoii(:,kk),170/obj.dt,'moving');
					end
					if plotFit, plot(obj.t(1:obj.lastIdx),filtered); end
					if plotFit,	figure(f); end
					out = rhoii-filtered;
					full = 1;
				case 'rhoij'
					% out{1}: t x #off-diagonal elements
					% out{2}: [from,to] x #off-diagonal elements
					%			carries information to identify objects in out{1}
					if ~isfield(obj.tresults,'rho') || isempty(obj.tresults.rho)
						error('TDVPData:getData:rhoij','rho does not exist')
					end
					r = obj.tresults.rho(1:obj.lastIdx,:,:);
					d = size(r);
					out{1} = zeros(d(1),d(2)*(d(2)-1)/2-1);				% calculates number of off-diagonals
					out{2} = zeros(2,size(out,2));
					iC = 1;
					for jj = 1:d(2)
						for ii = jj:d(2)
							if ii ~= jj
								out{1}(:,iC) = r(:,ii,jj);				% get offdiag
								out{2}(:,iC) = [jj,ii];
								iC = iC+1;
							end
						end
					end
					full = 1;
                case 'sys-env-x'
					out = obj.getSysEnvObs('x');			% returns t x NC cell array; using mps(:,2), Vmat(:,2)
					full = 1;
                case 'sys-env-n'
					out = obj.getSysEnvObs('n');			% returns t x NC cell array; using mps(:,2), Vmat(:,2)
                    full = 1;
				case 'spin'
					
			end
			
			if ~full
				out = out(1:obj.tresults.lastIdx-idxOffset);	% truncate if wanted
			end
		end
		
		function [pl,obj] = plot(obj,type,varargin)
			% initialise modifiers
			% plot(...,ax_handle)	Plots into the axes given by handle
			if length(obj) > 1
				% deal with object array
				pl = gobjects(length(obj),1);
				for ii = 1:length(obj)
					[temp,obj(ii)] = obj(ii).plot(type,varargin{:});
					temp = reshape(temp,1,[]);
					if size(pl,2) ~= size(temp,2)
						pl(end,size(temp,2)) = gobjects(1,1);
					end
					pl(ii,:) = temp;
				end
				return;
			end
			h.xlbl = 't';
			h.ylbl = [];
			ts = 1;						% scale time axis
			eScale = 0;					% energy units used for DFT: 0 = none, 1 = eV, 2 = cm (wavenumber)
			unicolor = 0;
			resetColorOrder = 0;		% start from index 1
			plotOpt = {};				% additional plotOptions from varargin
			DFTplot = 0;				% plotting DFT data
			DFTshift = 0;				% shift the fft results
			normalise = 0;				% normalise to maximum peak (for FFT especially)
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV and eV scale in DFT plots
						ts = 0.658;
						eScale = 1;
						h.xlbl = '$t/fs$';
					case '-cmev'
						% cm scale in DFT plots
						ts = 0.658;
						eScale = 2;
						h.xlbl = '$E/cm^{-1}$';
					case '-nmev'
						% nm scale in DFT plots
						ts = 0.658;
						eScale = 3;
						h.xlbl = '$\lambda/nm$';
					case '-fftshift'
						DFTshift = 1;
					case '-unicol'
						% same colors on all lines
						unicolor = 1;
					case '-resetcolororder'
						resetColorOrder = 1;
					case '-norm'
						normalise = 1;
					otherwise
						% pass through as direct plot options!
						if isa(varargin{m},'matlab.graphics.axis.Axes')
							axes(varargin{m});
						else
							plotOpt = [plotOpt, varargin(m)];
						end
				end
			end
			
			hold all; ax = gca;
			
			if resetColorOrder
				ax.ColorOrderIndex = 1;
			end
			
			if unicolor
				idx = ax.ColorOrderIndex;
			end
			
			switch lower(type)
				case 'sz'
					pl = plot(obj.t(1:obj.lastIdx)*ts, obj.tresults.spin.sz(1:obj.lastIdx));
					h.ylbl = '$\left<\sigma_z\right>$';
				case 'spin'
					if isempty(obj.spin)
						disp('please calculate spin first');
						return;
					else
						pl = plot(obj.t(1:obj.lastIdx)*ts, obj.spin);
						pl(4) = plot(obj.t(1:obj.lastIdx)*ts, sqrt(obj.spin(:,1).^2+obj.spin(:,2).^2));
						pl(1).DisplayName = '$\left<\sigma_x\right>$';
						pl(2).DisplayName = '$\left<\sigma_y\right>$';
						pl(3).DisplayName = '$\left<\sigma_z\right>$';
						pl(4).DisplayName = '$\sqrt{\left<\sigma_x\right>^2+\left<\sigma_y\right>^2}$';
					end
					h.ylbl = '$\left<\sigma\right>$';
				case 'calctime'
					pl = plot(obj.t(2:obj.lastIdx)*ts,obj.para.tdvp.calcTime(1:obj.lastIdx-1),'Displayname',obj.LegLabel);
					h.ylbl = 'CPU time/h';
				case 'calctime-d'
					% 1st derivative, in hours
					pl = plot(obj.t(2:obj.lastIdx-1)*ts,diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1)),'Displayname',obj.LegLabel);
					h.ylbl = 'CPU time/sweep/h';
				case 'calctime-d-sec'
					% 1st derivative, in seconds
					pl = plot(obj.t(2:obj.lastIdx-1)*ts,3600*diff(obj.para.tdvp.calcTime(1:obj.lastIdx-1)),'Displayname',obj.LegLabel);
					h.ylbl = 'CPU time/sweep/s';
				case 'rhoii'
					rhoii = gettRhoiiSystem(obj);
					pl = plot(obj.t(1:obj.lastIdx)*ts,abs(rhoii(1:obj.lastIdx,:)), plotOpt{:},'Displayname',obj.LegLabel);
					h.ylbl = '$\rho_{ii}$';
				case 'rho-current'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.tresults.rho(1:obj.lastIdx,:,:);
					d = size(r);
					rhoDiag = zeros(d([1,2]));
					LegLabD = cell(1,d(2));
					rhoCur = zeros(d(1),d(2)*(d(2)-1)/2-1);				% calculates number of off-diagonals
					LegLabCur = cell(1,size(rhoCur,2));
					iC = 1;
					for jj = 1:d(2)
						for ii = 1:jj
							if ii == jj
								rhoDiag(:,ii) = real(r(:,ii,jj));		% get population
								LegLabD{ii} = sprintf('$%d$',ii);
							else
								rhoCur(:,iC)  = real(r(:,ii,jj));		% get Current
								LegLabCur{iC} = sprintf('$%d\\to%d$',ii,jj);
								iC = iC+1;
							end
						end
					end
					% resize ax and add top axis for current!
					ax.Position(4) = ax.Position(4)/2;
					box on;
 					pl1 = plot(obj.t(1:obj.lastIdx)*ts,rhoDiag, plotOpt{:},'Displayname',obj.LegLabel);
					ax2 = axes('Position',ax.Position);
					ax2.Position(2) = ax2.Position(2)+ax2.Position(4);
					pl2 = plot(obj.t(1:obj.lastIdx)*ts,rhoCur, plotOpt{:},'Displayname',obj.LegLabel);
% 					ax2.XTickLabel = [];
					ax2.XAxisLocation = 'top';
					ax2.YAxisLocation = 'right';
					ylabel('Im($\rho_{ij})$')
					pl = [pl1;pl2];
					set(pl,{'Displayname'},[LegLabD,LegLabCur]');
					h.ylbl = '$\rho_{ii}$';
					axes(ax);
				case 'rho-dpmes'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.tresults.rho(1:obj.lastIdx,:,:);
					d = size(r);
					rhoDiag = zeros(d([1,2]));
					LegLabD = cell(1,d(2));
					rhoCur = zeros(d(1),d(2)*(d(2)-1)/2-1);				% calculates number of off-diagonals
					LegLabCur = cell(1,size(rhoCur,2));
					iC = 1;
					for jj = 1:d(2)
						for ii = 1:jj
							if ii == jj
								rhoDiag(:,ii) = real(r(:,ii,jj));		% get population
								LegLabD{ii} = sprintf('$%d$',ii);
							else
								rhoCur(:,iC)  = real(r(:,ii,jj));		% get Current
								LegLabCur{iC} = sprintf('$%d\\to%d$',ii,jj);
								iC = iC+1;
							end
						end
					end
					% resize ax and add top axis for current!
					ax.Position(4) = ax.Position(4)/2;
					box on;
 					pl1 = plot(obj.t(1:obj.lastIdx)*ts,rhoDiag, plotOpt{:},'Displayname',obj.LegLabel);
					ax2 = axes('Position',ax.Position);
					ax2.Position(2) = ax2.Position(2)+ax2.Position(4);
					pl2 = plot(obj.t(1:obj.lastIdx)*ts,rhoCur(:,[2,5,7,9]), plotOpt{:},'Displayname',obj.LegLabel);		% select non-vanishing only!
					LegLabD = {'$TT$','$LE^+$','$LE^-$','$CT^+$','$CT^-$'};
					LegLabCur = {'$LE^- \to TT$','$CT^+ \to LE^+$','$CT^- \to TT$','$CT^- \to LE^-$'};
% 					ax2.XTickLabel = [];
					ax2.XAxisLocation = 'top';
					ax2.YAxisLocation = 'right';
					legend toggle
					ylabel('Re($\rho_{ij})$')
					pl = [pl1;pl2];
					set(pl,{'Displayname'},[LegLabD,LegLabCur]');
					h.ylbl = '$\rho_{ii}$';
					axes(ax);
				case 'rhoij-real'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.getData('rhoij');							% {rhoij, info}
					LegLabCur = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					pl = plot(obj.t(1:obj.lastIdx)*ts, real(r{1}), plotOpt{:},'Displayname',obj.LegLabel);
					box on;
					legend toggle
					set(pl,{'Displayname'},LegLabCur);
					h.ylbl = 'Re($\rho_{ij})$';
				case 'rhoij-imag'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.getData('rhoij');							% {rhoij, info}
					LegLabCur = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					pl = plot(obj.t(1:obj.lastIdx)*ts, imag(r{1}), plotOpt{:},'Displayname',obj.LegLabel);
					box on;
					legend toggle
					set(pl,{'Displayname'},LegLabCur);
					h.ylbl = 'Im($\rho_{ij})$';
				case 'rhoij-abs'
					if ~isfield(obj.tresults,'rho'), return, end;
					r = obj.getData('rhoij');							% {rhoij, info}
					LegLabCur = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					pl = plot(obj.t(1:obj.lastIdx)*ts, abs(r{1}), plotOpt{:},'Displayname',obj.LegLabel);
					box on;
					legend toggle
					set(pl,{'Displayname'},LegLabCur);
					h.ylbl = '$|\rho_{ij}|$';
				case 'hshi'
					pl = plot(obj.t(1:obj.lastIdx)*ts,[obj.tresults.hshi(1:obj.lastIdx,:),sum(obj.tresults.hshi(1:obj.lastIdx,:),2)]);
					h.ylbl = '$\left< H_i \right>$';
				case 'stateproj'
					pl = plot(obj.t(1:obj.lastIdx)*ts, [abs(obj.stateProj(1:obj.lastIdx)),real(obj.stateProj(1:obj.lastIdx)),imag(obj.stateProj(1:obj.lastIdx))]);
					h.ylbl = 'Autocorrelation';
				case 'chain-x-t-avg'
					hold all;
					h.ydata = squeeze(sum(real(obj.xC(1:obj.lastIdx,:,:,:)),3));		% t x L x  nChain
					h.ydata = permute(h.ydata,[1 3 2]);				% t x state x L x chain
					pl = plot(obj.t(1:obj.lastIdx)*ts,h.ydata(:,:,2));
					h.ylbl = '$\left< x_k \right>$';
					
				case 'linabs'
					% linear absorption as DFT of stateProj autocorrelation function
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
% 					m = 5000;
					maxN = m;
% 					maxN = pow2(nextpow2(1*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					linAbs = fft(conj(obj.stateProj(1:m)),maxN);	% do conj to get positive real part!
					if DFTshift
						linAbs = fftshift(linAbs);
						f = f-f(end)/2;
					end
% 					pl = plot(f, [real(linAbs),imag(linAbs),abs(linAbs)]);
					pl = plot(f, real(linAbs));
					h.ylbl = 'Linear Absorption';
				case 'rhoii-ft'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					rhoii = gettRhoiiSystem(obj);		% t x nStates
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
					h.ylbl = '$FT(\rho_{ii})$';
				case 'rhoii-osc-res'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					if isempty(obj.rhoOscRes)
						obj.rhoOscRes = obj.getData('rhoii-osc-res');		% t x nStates
					end
					rhoii = obj.rhoOscRes;
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
					h.ylbl = '$FT(\rho_{ii})$';
				case 'rhoii-osc-res-med'
					% applies DFT to the population probability of rho
					DFTplot = 1;
					m = obj.lastIdx;					% last datapoint to include
					window = hann(m,'periodic');
% 					maxN = m;
					maxN = pow2(nextpow2(10*m));			% if > lastIdx -> zero padding
					f = (0:maxN-1)/obj.t(2)/maxN;
					if isempty(obj.rhoOscRes)
						obj.rhoOscRes = obj.getData('rhoii-osc-res-med');		% t x nStates
					end
					rhoii = obj.rhoOscRes;
					ft = fft(real(rhoii(1:m,:)).*(window*ones(1,size(rhoii,2))),maxN,1);
% 					ft = fft(real(rhoii(1:m,:)),maxN,1);
					if DFTshift
						ft = fftshift(ft,1);
						f = f-f(end)/2;
					end
					pl = plot(f, abs(ft));
					h.ylbl = '$FT(\rho_{ii})$';
				otherwise
					error('TDVPData:plot','PlotType not avaliable');
			end
			
			if DFTplot == 1
				if ts ~= 1
					f = f/0.658;
				end
				if eScale == 1
					f = f*4.135; % in eV
					h.xlbl = '$E/eV$';
				elseif eScale == 2
					f = f*4.135*8065.73; % in cm
				elseif eScale == 3
					f = 1239.84193./(f*4.135);		% in nm: hc/(E in eV);
				end
				for k = 1:length(pl)
					pl(k).XData = f(1:length(pl(k).XData));
				end
			end
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			if unicolor
				arrayfun(@(x) set(x,'Color',pl(1).Color), pl);
				ax.ColorOrderIndex = idx + 1;
			end
% 			figure; plot(obj.t(1:obj.lastIdx)*ts,abs(rhoii(1:obj.lastIdx,:)).*(window*ones(1,size(rhoii,2))));		% auxiliary plot for hann-windowed rhoii-ft
		end
		
		function h   = plotSld1D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			% default: Plot versus time
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logY = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (obj.t(1:obj.lastIdx)*h.ts).';
			h.ydata = [];				% T x L x NC x ...  if not, needs to be reshaped!
			h.noSldDims = 1;			% default: only plot 1 dim
			h.xSize = length(h.xdata)*ones(1,obj.nChains);
			
			h.xlbl = '$t$';
			h.ylbl = '';
			h.tlbl = '';
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.xlbl = '$t/fs$';
						h.xdata = h.xdata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logY = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
				
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
% 			if ~isempty(strfind(lower(type),'star'))
% 				% need to find lengths of chains in star picture -> length of x-axis
% 				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
% % 					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
% 				else
% % 					h.xSize = size(obj.omega,1)*ones(1,h.nChains);
% 				end
% 			end
			
			switch lower(type)
				case 'chain-n-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t';
				case 'chain-n-d-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occCd(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t - diabatic';
				case 'chain-n-a-t'
					% Plot n(t), slider in k & NC
					h.ydata = real(obj.occCa(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< n_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Occupation vs t - adiabatic';
				case 'chain-n-k'
					% Plot n(k), slider in t & NC
					h.ydata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x nChain
					h.ydata = permute(h.ydata,[2,1,3]);					% L x t x nChain
					h.ylbl = '$\left< n_k \right>$';
					h.xdata = (1:obj.para.L).';
					h.xSize = obj.para.L*ones(1,obj.nChains);
					h.xlbl = 'Site $k$';
					h.sldlbl = {'Time t =','Chain'};
					h.tlbl = 'Chain Occupation vs k';
				case 'chain-x-t'
					h.ydata = real(obj.xC(1:obj.lastIdx,:,:,:));		% t x L  x nChain
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-d-t'
					h.ydata = real(obj.xCd(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement - diabatic';
				case 'chain-x2-d-t'
					h.ydata = real(obj.xC2d(1:obj.lastIdx,:,:,:));		% t x L x state x nChain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'Site k =','Chain'};
					h.tlbl = 'Chain Displacement squared - diabatic';
				case 'chain-x-t-avg'
					hold all;
					h.ydata = squeeze(sum(real(obj.xC(1:obj.lastIdx,:,:,:)),3));		% t x L x  nChain
					h.ydata = permute(h.ydata,[1 3 2]);				% t x state x L x chain
					h.noSldDims = 2;
					h.ylbl = '$\left< x_k \right>$';
					h.sldlbl = {'Site k ='};
					h.tlbl = 'Chain Displacement';
				case 'star-n-t'
					h.ydata = real(obj.occS(1:obj.lastIdx,:,:));		% t x w x nChain
					h.yPlots = 1;
					h.ylbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x-t'
					hold all;
					h.ydata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.ydata = permute(h.ydata,[1 3 2 4]);				% t x state x w x chain
					h.noSldDims = 2;									% first 2 dims without Slider
					h.ylbl = '$\left< f_k \right>$';
					if ~h.evTocm
% 						h.xdata = obj.omega;							% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $eV$';
					else
% 						h.xdata = obj.omega./1.23984e-4;				% w x nChain
% 						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'w =','Chain'};
					h.tlbl = 'Star Displacement';
				case 'state-adiab'
					hold all;
					h.ydata = obj.sysState(1:obj.lastIdx,:,:).*conj(obj.sysState(1:obj.lastIdx,:,:));			% t x dk x D; calc the probability
					h.ydata(:,end+1,:) = sum(h.ydata,2);
					h.ylbl = '$|\Psi_k|^2$';
					h.noSldDims = 2;
					h.tlbl = 'Adiabatic State evolution';
					h.sldlbl = {'Bond #'};
			end
			
			h.f.Name = h.tlbl;
			
			if h.logY
				h.ydata = sign(h.ydata) .* log10(abs(h.ydata));
				h.ylbl = ['$\log_{10}',h.ylbl(2:end)];
			end
			
			h.nSld = ndims(h.ydata)-h.noSldDims;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);					% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			
			if h.noSldDims == 1
				h.pl{1} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,h.SldIdx{:}));
			elseif h.noSldDims == 2
				hold all;
				for ii = 1:size(h.ydata,2)
					h.pl{ii} = plot(h.xdata(1:h.xSize(1),1),h.ydata(:,ii,h.SldIdx{:}));
				end
			end
			axis tight
			grid on
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.ysize(h.noSldDims+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_1D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_1D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
				for kk = 1:length(h.pl)
					if length(h.pl) == 1
						set(h.pl{1} ,'ydata', h.ydata(:,h.SldIdx{:}));
					else
						set(h.pl{kk},'ydata', h.ydata(:,kk,h.SldIdx{:}));
					end
				end
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSld1DFT(obj, type, varargin)
			%% Plot with Slider to change DFT range and window / padding
			% No slider in dataset here. Only in DFT parameters
			% default: Plot versus freq
			h = struct();				% struct containing all infos & handles
			h.freqScale = 1;			% scale freq axis
			h.fInvert = 0;				% need 1/f for nm scale?
			h.logY = 0;					% linear y-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.normalise = 0;
			h.xdata = obj.t(1:obj.lastIdx).';	% the time axis
			h.ydata = [];				% T x L x NC x ...  if not, needs to be reshaped!
			h.noSldDims = 1;			% default: only plot 1 dim
			h.xSize = length(h.xdata)*ones(1,obj.nChains);
			
			
			h.xlbl = '$f$';
			h.ylbl = '';
			h.tlbl = '';
			h.llbl = {};
			
			% FFT settings
			h.data = [];								% FFT done in 1st dimension
			h.dataRange = obj.lastIdx;					% last (real) datapoint to include
			h.zeroPadFactor = 0;						% multiples of dataset to pad
			h.power2 = 0;								% FFT in power of 2?
			h.useWindowFcn = 1;							% whether to use the Hann window function
			h.FFTshift = 0;
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-ev'
						% ev scale for H in eV
						h.freqScale = h.freqScale/0.658*4.135;
						h.xlbl = '$E/eV$';
					case '-cmev'
						% use cm^-1 as Units
						h.freqScale = h.freqScale/0.658*4.135*8065.73;
						h.xlbl = '$E/cm^{-1}$';
					case '-nmev'
						% nm scale, H in ev
						h.freqScale = h.freqScale/0.658*4.135/1239.84193;
						h.fInvert = 1;
						h.xlbl = '$\lambda/nm$';
					case '-log'
						% Logarithmic scale in z
						h.logY = 1;
					case '-fftshift'
						h.FFTshift = 1;
					case '-norm'
						h.normalise = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			% define dataset for FFT
			switch lower(type)
				case 'linabs'
					% linear absorption as DFT of stateProj autocorrelation function
					h.data = conj(obj.stateProj(1:obj.lastIdx));
					h.useWindowFcn = 0;								% needs to be switched off!!
				case 'rhoii-ft'
					% applies DFT to the population probability of rho
					rhoii = gettRhoiiSystem(obj);		% t x nStates
					h.data = real(rhoii(1:obj.lastIdx,:));
					h.noSldDims = 2;					% plot 2nd dim simultaneously
				case 'rhoii-osc-res'
					rhoii = obj.getData('rhoii-osc-res');
					h.data = rhoii;
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
				case 'rhoij-imag'
					r = obj.getData('rhoij');							% {rhoij, info}
					h.llbl = arrayfun(@(i) sprintf('$%d\\to%d$',r{2}(1,i),r{2}(2,i)),(1:size(r{2},2))','UniformOutput',false);
					h.data = imag(r{1});
					h.noSldDims = 2;
% 					h.useWindowFcn = 0;
			end
			
			calcFFT();				% fills h.ydata with FFT
			
			h.f.Name = h.tlbl;
			
			if h.logY
				h.ydata = sign(h.ydata) .* log10(abs(h.ydata));
				h.ylbl = ['$\log_{10}',h.ylbl(2:end)];
			end
			
			if ~isvector(h.ydata)
				h.nSld = 2+ndims(h.ydata)-h.noSldDims;				% number of sliders needed; +1 for DFT
			else
				h.nSld = 2;
			end
			h.ysize = size(h.data);
			h.sldlbl = {'tMax','nPad'};
			h.sldInitVal= [h.ysize(1),0];
			h.sldLimits = [1,h.ysize(1); 0, 100];					% [min1, max1; min2, max2; ...]
			h.SldIdx = num2cell(ones(1,h.nSld),1);					% indices for each slider dimension, indicating currently displayed slice
			
			h.pl = plot(h.xdata, plotSpec());		% plotspec returns the actual data from h.ydata type-specific
			if ~isempty(h.llbl)
				set(h.pl,{'DisplayName'},h.llbl);					% h.llbl needs to be same shape as h.pl
			end
			
			axis tight
			grid on
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,h.sldInitVal(ii),1,h.sldLimits(ii,1),h.sldLimits(ii,2)+1);									%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_1D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_1D_Sld(source, callbackdata, n)
				% Callback for 1D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
				h.dataRange = h.SldIdx{1};
				h.zeroPadFactor = h.SldIdx{2};
				calcFFT();
				out = plotSpec();
				for kk = 1:length(h.pl)
					if length(h.pl) == 1
						set(h.pl(1) ,'xdata',h.xdata,'ydata', out);
					else
						set(h.pl(kk),'xdata',h.xdata,'ydata', out(:,kk));
					end
				end
			end
			
			function calcFFT()
				% performs the FFT. Will be called after each slider adjustment
				maxN = h.dataRange*(1+h.zeroPadFactor);
				if h.power2
					maxN = pow2(nextpow2(maxN));
				end
				h.xdata = (0:maxN-1)/obj.t(2)/maxN;			% get frequency	
				if h.useWindowFcn
					window = hann(h.dataRange,'periodic');
					h.ydata = fft(h.data(1:h.dataRange,:).*(window*ones(1,size(h.data,2))),maxN,1);				% do FFT in 1st dimension
				else
					h.ydata = fft(h.data,maxN,1);			% do FFT in 1st dimension
				end
				if h.FFTshift
					h.ydata = fftshift(h.ydata,1);			% shift to have -f/2 : f/2
					h.xdata = h.xdata - h.xdata(end)/2;
				end
				h.xdata = h.xdata * h.freqScale;
				if h.fInvert
					h.xdata = 1./h.xdata;					% necessary for wavelength plots
				end
				h.xSize = length(h.xdata);
			end
			
			function out = plotSpec()
				% define, which components of the DFT will be plotted, real imag or abs
				switch lower(type)
					case 'linabs'
						% linear absorption as DFT of stateProj autocorrelation function
						out = [real(h.ydata),imag(h.ydata)];
					case 'rhoii-ft'
						% applies DFT to the population probability of rho
						out = abs(h.ydata);
					case 'rhoii-osc-res'
						% applies DFT to the residual of the populations of rho
						out = abs(h.ydata);
					case 'rhoij-imag'
						out = abs(h.ydata);
				end
				if h.normalise
					out = bsxfun(@rdivide,out,max(out,[],1));
				end
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSld2D(obj, type, varargin)
			%% Plot with Slider to flip through different 2D plots
			h = struct();				% struct containing all infos & handles
			h.ts = 1;					% scale time axis
			h.logZ = 0;					% linear z-axis by default
			h.evTocm = 0;				% convert all eV to cm^-1
			h.xdata = (1:obj.para.L).';
			h.ydata = obj.t(1:obj.lastIdx)*h.ts;
			h.zdata = [];					% T x L x NC x ...  if not, needs to be reshaped!
			h.xSize = obj.para.L*ones(1,obj.nChains);	% size for each slider value
			
			if obj.nChains > 1 && obj.para.useTreeMPS
				h.xSize = cellfun(@(x) x.L,obj.para.chain)+1;
				h.xdata = (1:max(h.xSize))'*ones(1,obj.nChains);
			end
			
			h.xlbl = 'Site $k$';
			h.ylbl = '$t$';
			h.zlbl = '';
			h.tlbl = '';
			
			for m = 1:nargin-2
				switch lower(varargin{m})
					case '-fsev'
						% fs timescale for H in eV
						h.ts = 0.658;
						h.ylbl = '$t/fs$';
						h.ydata = h.ydata*h.ts;
					case '-log'
						% Logarithmic scale in z
						h.logZ = 1;
					case '-cm'
						% use cm^-1 as Units
						h.evTocm = 1;
				end
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.ax = gca;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			if ~isempty(strfind(lower(type),'star'))
				% need to find lengths of chains in star picture -> length of x-axis
% 				if strcmp(obj.para.chain{1}.mapping, 'LanczosTriDiag')		% take a representative
% 					h.xSize = cellfun(@(x) length(x.xi), obj.para.chain);
% 				else
					h.xSize = size(obj.omega,1)*ones(1,obj.nChains);
					h.ydata = obj.tS;
					h.ySize = length(h.ydata);
% 				end
			end
			
			switch lower(type)
				case 'chain-n'
					h.zdata = real(obj.occC(1:obj.lastIdx,:,:));		% t x L x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Occupation';
				case 'chain-n-d'
					h.zdata = real(obj.occCd(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Occupation - diabatic';
				case 'chain-n-a'
					h.zdata = real(obj.occCa(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< n_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Occupation - adiabatic';
				case 'chain-x'
					h.zdata = real(obj.xC(1:obj.lastIdx,:,:));			% t x L x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-d'
					h.zdata = real(obj.xCd(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement - diabatic';
				case 'chain-x-a'
					h.zdata = real(obj.xCa(1:obj.lastIdx,:,:,:));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement - adiabatic';
				case 'chain-x-avg'
					h.zdata = squeeze(sum(real(obj.xCa(1:obj.lastIdx,:,:,:)),3));		% t x L x state x chain
					h.zlbl = '$\left< x_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x-ft'
					h.maxN = pow2(nextpow2(obj.lastIdx));				% FT window length
					h.ydata = (0:h.maxN/2)/h.ydata(end);				% fs * k/N = k/T where k=0... N/2
					h.ylbl = '$f$ in $1/fs$';
					if h.evTocm && h.ts ~=1
						h.ydata = h.ydata*4.135*8065.73;
						h.ylbl = '$f/cm^{-1}$';
					end
					h.zdata = fft(real(obj.xC(1:obj.lastIdx,:,:,:)),h.maxN,1);		% f x L x state x chain
					h.zdata = 2*abs(h.zdata(1:h.maxN/2+1,:,:,:));
					h.zlbl = '$FT(\left< x_k \right>)$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement';
				case 'chain-x2'
					h.zdata = real(obj.xC2(1:obj.lastIdx,:,:));			% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement squared';
				case 'chain-x2-d'
					h.zdata = real(obj.xC2d(1:obj.lastIdx,:,:,:));		% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement squared - diabatic';
				case 'chain-x2-a'
					h.zdata = real(obj.xC2a(1:obj.lastIdx,:,:,:));		% t x L x chain
					h.zlbl = '$\left< x^2_k \right>$';
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Chain Displacement squared - adiabatic';
				case 'chain-x-unc'										% uncertainty in x
					x = real(obj.xC(1:obj.lastIdx,:,:));
					x2 = real(obj.xC2(1:obj.lastIdx,:,:));
					h.zdata = sqrt(x2-x.^2);							% t x L x chain
					h.zdata(:,1,:) = h.zdata(:,1,:) + 0.5;				% balance spin site
					h.zlbl = '$\Delta x_k$';
					h.sldlbl = {'Chain'};
					h.tlbl = 'Chain Displacement - uncertainty';
				case 'star-n'
					h.zdata = real(obj.occS(1:h.ySize,:,:));			% t x w x nChains
					h.zlbl = '$\left< n(\omega) \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'Chain'};
					h.tlbl = 'Star Occupation';
				case 'star-x'
					h.zdata = real(obj.xS(1:obj.lastIdx,:,:,:));		% t x w x state x chain
					h.zlbl = '$\left< f_k \right>$';
					if ~h.evTocm
						h.xdata = obj.omega;							% w x nChain
						h.xlbl = 'Mode $\omega$ in $eV$';
					else
						h.xdata = obj.omega./1.23984e-4;				% w x nChain
						h.xlbl = 'Mode $\omega$ in $cm^{-1}$';
					end
					h.sldlbl = {'State','Chain'};
					h.tlbl = 'Star Displacement';
				case 'state-adiab'
					h.zdata = obj.sysState(1:obj.lastIdx,:,:).*conj(obj.sysState(1:obj.lastIdx,:,:));			% t x dk x D; calc the probability
					h.zlbl = '$|\Psi_k|^2$';
					h.xlbl = 'Diabatic States';
					h.xdata = (1:size(obj.sysState,2)).';
					h.xSize = size(obj.sysState,2)*ones(1,obj.nChains);
					h.tlbl = 'Adiabatic State evolution';
					h.sldlbl = {'Bond State'};
					
			end
			h.f.Name = h.tlbl;
			
			if h.logZ
				h.zdata = sign(h.zdata) .* log10(abs(h.zdata));
				h.zlbl = ['$\log_{10}',h.zlbl(2:end)];
			end
			
			h.nSld = ndims(h.zdata)-2;					% number of sliders needed
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.ysize = size(h.ydata);
			h.zsize = size(h.zdata);
			
			h.pl = surf(h.xdata(1:h.xSize(1),1),h.ydata,h.zdata(:,1:h.xSize(1),h.SldIdx{:}));
			shading interp
			rotate3d on
			axis tight
			h.ax.View = [0 90];
			h.ax.TickDir = 'out';
			xlabel(h.xlbl);
			ylabel(h.ylbl);
			zlabel(h.zlbl);
			h.cb = colorbar; h.cb.Title.Interpreter = 'latex';
			h.cb.Title.String = h.zlbl;

			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.zsize(2+ii)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				if size(h.xdata,2) > 1 && size(h.xdata,2) == size(h.zdata,n+2)
					% high probability that current slider is going through chains
					mc = round(source.Value);
					set(h.pl,'xdata', h.xdata(1:h.xSize(mc),mc));
					set(h.pl,'zdata', h.zdata(:,1:h.xSize(mc),h.SldIdx{:}));
					h.ax.CLim = h.ax.ZLim;
				else
					xs = length(get(h.pl,'xdata'));
					set(h.pl,'zdata', h.zdata(:,1:xs,h.SldIdx{:}));
					h.ax.CLim = h.ax.ZLim;
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function h   = plotSldBloch(obj, type, varargin)
			h = struct();
			h.xlbl = '$\left<sigma_x\right>$';
			h.ylbl = '$\left<sigma_y\right>$';
			h.zlbl = '$\left<sigma_z\right>$';
			h.tlbl = '';
			h.linewidth = 5;
			if isempty(obj.rho)
				error('need reduced density matrix for this function!');
			end
			assert(size(obj.rho,2) == 2, 'Can only do this for 2-lvl systems right now');
			
			% Observables to compute
			[sigmaX,sigmaY,sigmaZ] = spinop('Z');
			h.sigmaX = reshape(sigmaX.',[],1);
			h.sigmaY = reshape(sigmaY.',[],1);
			h.sigmaZ = reshape(sigmaZ.',[],1);
			
			% reshape rho into convenient shape
			h.d = size(obj.rho);		% t x i x j x k (states)
			if length(h.d) == 4
				h.Nstates = h.d(4);
				h.rho = reshape(obj.rho,h.d(1),[],h.d(4));
				h.sv = zeros(h.d(1),h.Nstates-1);
				h.tlbl = 'Adiabatic Spin evolution';
			else
				h.Nstates = 1;
				h.rho = reshape(obj.rho,h.d(1),[]);
				h.sv = [];			% not used since no sv existing
				h.tlbl = 'Spin Evolution';
			end
			
			for ii = 2:h.Nstates
				% extract the SV^2 to plot bloch vectors with correct length
				h.sv(:,ii-1) = real(diag(squeeze(h.rho(:,:,1))*squeeze(h.rho(:,:,ii))'));	% achieves the same
			end
			
			h.xdata = zeros(h.d(1),h.Nstates);
			h.xsize = size(h.xdata);
			h.ydata = zeros(h.d(1),h.Nstates);
			h.ysize = size(h.ydata);
			h.zdata = zeros(h.d(1),h.Nstates);
			h.zsize = size(h.zdata);
			for ii = 1:h.Nstates
				% compute <sigma> of all rho
				h.xdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaX);
				h.ydata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaY);
				h.zdata(:,ii) = real(squeeze(h.rho(:,:,ii))*h.sigmaZ);
			end
			
			% Create figure handles and panels
			h.f = figure();
			h.f.Name = h.tlbl;
			h.ax = gca; hold all;
			% fix axes size and add space to the right
			h.ax.Units = 'pixels';
			h.f.Position(3) = h.f.Position(3)+100;
			h.controlPanel = uipanel('Tag','Panel','Units','pixels','Position',[h.f.Position(3)-100,1,100,h.f.Position(4)]);
% 			set(h.f,'DefaultLineLineWidth',h.linewidth);
			h.ax.Color = 'none';

			
			% set normalised units to enable scaling with window size
			h.ax.Units = 'norm';
			h.controlPanel.Units = 'norm';
			
			% Slider options
			h.nSld = 1;					% Use slider only in t
			h.SldIdx = num2cell(ones(1,h.nSld),1);		% indices for each slider dimension, indicating currently displayed slice
			h.sldlbl = {'Time'};
			
			% Create Plot for t = 0
			h.sphereon = true;
			if h.sphereon
				sphere
				daspect([1 1 1])
				alpha(0.2)
% 				h.ax.Children.Linestyle = ':';			% thinner mesh
				set(get(gca,'children'),'linestyle',':','linewidth',0.5)
			end
% 			scatter3(tresults.spin.sx,tresults.spin.sy,tresults.spin.sz,20,'filled');
			h.pl = cell(h.Nstates,1);
			for ii = 1:h.Nstates
				if ii == 1
% 					h.pl{ii} = plot3([0,h.xdata(h.SldIdx{:},ii)],[0,h.ydata(h.SldIdx{:},ii)],[0,h.zdata(h.SldIdx{:},ii)]);
					h.pl{ii} = quiver3(0,0,0,h.xdata(h.SldIdx{:},ii),h.ydata(h.SldIdx{:},ii),h.zdata(h.SldIdx{:},ii),1,...
								'LineWidth',h.linewidth);
				else
					h.pl{ii} = quiver3(0,0,0,0,0,0,1,'LineWidth',h.linewidth*0.5);
% 					h.pl{ii} = plot3([0,0],[0,0],[0,0],'LineWidth',h.linewidth*0.5);		% dummy initialise! assume always pure initial state
				end
			end
			h.ax.XLim = [-1,1];
			h.ax.YLim = [-1,1];
			h.ax.ZLim = [-1,1];
			h.ax.View = [-29,16];
			rotate3d on
			
			%
			% Create Slider(s) inside h.controlPanel
			h.sld_w = 70; h.sld_h = 20;
			h.cP_padIn = 5;		% controlPanel padding inside
			for ii = 1:h.nSld		% only have 1 slider!!
				h.sldText{ii} = uicontrol('Parent',h.controlPanel,'Style','text','String',sprintf('%s %d',h.sldlbl{ii},1),...
										  'HorizontalAlignment','left','FontSize',10,'FontName',h.ax.FontName);
				h.sld{ii} = javax.swing.JScrollBar(0,1,1,1,h.xsize(1)+1);		%JScrollBar(int orientation, int value, int extent, int min, int max)
				[~,h.sldContainer{ii}] = javacomponent(h.sld{ii}, [5, 5,h.sld_w,h.sld_h], h.controlPanel);	% position defined in posDisplay()
				h.sld{ii}.setUnitIncrement(1); h.sld{ii}.setBlockIncrement(3);
				h.hsld{ii} = handle(h.sld{ii},'CallbackProperties');
				set(h.hsld{ii},'AdjustmentValueChangedCallback',@(source,callbackdata) callback_2D_Sld(source, callbackdata,ii));%(source,callbackdata)  set(h.ax,'UserData',round(source.Value)));
			end
			posDisplay();
			set(h.f, 'ResizeFcn',@posDisplay);
			
			function callback_2D_Sld(source, callbackdata, n)
				% Callback for 2D Slider plots
				% needs to be sub-function due to shared handle h.
				%  n: number of dimension in z being changed
				h.SldIdx{n} = round(source.Value);
				h.sldText{n}.String = sprintf('%s %d', h.sldlbl{n},round(source.Value));
% 				fprintf('%d',h.SldIdx{:});
				tt = round(source.Value);
				for kk = 1:h.Nstates
					if kk == 1
						% update the full vector
						h.pl{1}.UData = h.xdata(tt,1);
						h.pl{1}.VData = h.ydata(tt,1);
						h.pl{1}.WData = h.zdata(tt,1);
					else
						% update the part vectors
						% get their origin from the previous vector
						if kk == 2
% 							x0 = 0; y0 = 0; z0 = 0;
							% do nothing
						else
							% set origin to end of previous quiver
							h.pl{kk}.XData = h.pl{kk-1}.XData+h.pl{kk-1}.UData;
							h.pl{kk}.YData = h.pl{kk-1}.YData+h.pl{kk-1}.VData;
							h.pl{kk}.ZData = h.pl{kk-1}.ZData+h.pl{kk-1}.WData;
						end
						% calculate their destination point
						h.pl{kk}.UData = h.xdata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.VData = h.ydata(tt,kk)*h.sv(tt,kk-1);
						h.pl{kk}.WData = h.zdata(tt,kk)*h.sv(tt,kk-1);
% 						set(h.pl{kk},'xdata', [x0,x1]);
% 						set(h.pl{kk},'ydata', [y0,y1]);
% 						set(h.pl{kk},'zdata', [z0,z1]);
					end
				end
	% 			fprintf('Source.Value: %g, Sld.Value: %g',source.Value,h.sld.getValue);
	% 			callbackdata
			end
			
			function posDisplay(varargin)
				for kk = 1:h.nSld
					h.sldText{kk}.Position      = [h.cP_padIn, h.f.Position(4)-(h.cP_padIn*kk+2*(kk-0.5)*h.sld_h) ,h.sld_w,h.sld_h];
					h.sldContainer{kk}.Position = [h.cP_padIn, h.sldText{kk}.Position(2)-h.sld_h,h.sld_w,h.sld_h];
				end
			end
			
		end
		
		function out = chainParaInfo(obj)
			% returns the parameters of each chain.
			out = [];
			for ii = 1:obj.para.nChains
				out(ii).xi = obj.para.chain{ii}.xi;
				out(ii).Gamma = obj.para.chain{ii}.Gamma;
				out(ii).epsilon = obj.para.chain{ii}.epsilon;
				out(ii).t = obj.para.chain{ii}.t;
			end
		end
		
		function exportCSV(obj,type,loc,varargin)
			% function used for exporting dataset of 'type' in obj-array to location loc: cell array
			%
			if length(obj) > 1
				for ii = 1:length(obj)
					obj(ii).exportCSV(type,loc{ii});
				end
				return;
			end
			
			% from now: loc is a string, obj is single object
			
			switch lower(type)
				case 'sz'
					x = reshape(obj.t(1:obj.lastIdx),[],1);
					y = reshape(obj.tresults.spin.sz(1:obj.lastIdx),[],1);
					out = [x,y];
				case 'chain-n'
					x = reshape(1:obj.para.L,[],1);
					y = reshape(obj.t(1:obj.lastIdx),[],1);
					z = obj.occC(1:obj.lastIdx,:,1);
					out = [0,x';y,z];
				case 'star-n'
					x = reshape(obj.omega,[],1);
					y = reshape(obj.tS,[],1);
					z = obj.occS(:,:,1);								% t x w x nChains
					% only pick first chain for now.
					out = [0,x';y,z];
				case 'star-x'
					x = reshape(obj.omega,[],1);
					y = reshape(obj.tS,[],1);
					z = real(obj.xS(:,:,1));								% t x w x nChains
					% only pick first chain for now.
					out = [0,x';y,z];
				otherwise
					error('Dataset type not supported yet!');
			end
			dir = fileparts(loc);
			if ~exist(dir,'dir')
				mkdir(dir);
			end
			csvwrite(loc,out);
			
        end
        
        function out = getSysEnvObs(obj,type,varargin)
			%% function out = getSysEnvObs(obj,type,varargin)
			%	Contract the environment states with an operator specified by
			%	type:
			%	 'n' : occupation
			%    'x' : displacement
			%
			%	Only for bosons on the 2nd site for now.
			%	
			%	out: NC x 1 cell
			%		with Op_(r',r) right observable containing the contracted operator
			NC = obj.para.nChains;
			out = cell(obj.lastIdx, NC);		% t x NC
			for mc = 1:NC
				% compute for all times simultaneously
				dk = cellfun(@(x) size(x{mc},1), obj.Vmat(1:obj.lastIdx,2));	% dk(t)
				bp = arrayfun(@(x) bosonop(x,0,'n'),dk,'UniformOutput',false);
				switch lower(type)
					% select the appropriate operator
					case 'n'
						op = cellfun(@(x) x*x', bp,'UniformOutput',false);
					case 'x'
						op = cellfun(@(x) (x+x')./2, bp,'UniformOutput',false);
				end
				out(:,mc) = arrayfun(@(t) updateCright([],obj.mps{t,2}{mc}, obj.Vmat{t,2}{mc},op{t},obj.mps{t,2}{mc}, obj.Vmat{t,2}{mc}),...
					(1:obj.lastIdx)','UniformOutput',false);
				
			end
		end
		
		function obj = getSpin(obj)
			h = struct();
			% Observables to compute
			[sigmaX,sigmaY,sigmaZ] = spinop('Z');
			h.sigmaX = reshape(sigmaX.',[],1);
			h.sigmaY = reshape(sigmaY.',[],1);
			h.sigmaZ = reshape(sigmaZ.',[],1);
			
			% reshape rho into convenient shape
			h.d = size(obj.rho);		% t x i x j x k (states)
			if length(h.d) == 4
				h.Nstates = h.d(4);
				h.rho = reshape(obj.rho,h.d(1),[],h.d(4));
				h.sv = zeros(h.d(1),h.Nstates-1);
				h.tlbl = 'Adiabatic Spin evolution';
			else
				h.Nstates = 1;
				h.rho = reshape(obj.rho,h.d(1),[]);
				h.sv = [];			% not used since no sv existing
				h.tlbl = 'Spin Evolution';
			end
			
			obj.spin = zeros(obj.lastIdx,3,h.Nstates,'single');
			for ii = 1:h.Nstates
				% compute <sigma> of all rho
				obj.spin(:,1,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaX);
				obj.spin(:,2,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaY);
				obj.spin(:,3,ii) = real(squeeze(h.rho(1:obj.lastIdx,:,ii))*h.sigmaZ);
			end
		end
	end
	
	% Static methods are functions that do not require 'obj' but are
    % relevant to methods that do.
	% Also some helper functions
    % They are called using TDVPData.myFun()
    methods(Static = true)
		function foldLib = getTDVPLib()
			filePattern = '20*\results-Till*.mat';
			foldLib = [rdir(['..\TDVP\',filePattern]);rdir(['..\TDVP\Data\',filePattern]);rdir(['..\cacheComputations\',filePattern]);...
				       rdir(['..\TDVP-Git\',filePattern]);rdir(['..\TDVP-Git\Data\',filePattern])];
			% remove 'incomplete' files
			foldLib = foldLib(arrayfun(@(x) isempty(strfind(x.name,'incomplete')),foldLib));
		end
		
		
		
	end
	
end